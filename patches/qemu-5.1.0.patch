From a9bafced71aa14b4734559543e491658358adb85 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 24 Apr 2019 20:16:48 -0700
Subject: [PATCH 1/7] build: Add support for iOS host

Fix build errors with clang
Block driver modified to handle iOS
Slirp driver modified to handle iOS
Calls to system() conditioned on not iOS build
Support iOS icache flushing
---
 block.c                   |  2 +-
 block/file-posix.c        | 38 +++++++++++++++++++-----------
 configure                 | 49 ++++++++++++++++++++++++++++++++++++++-
 net/slirp.c               | 16 ++++++-------
 qga/commands-posix.c      |  6 +++++
 target/arm/arm-semi.c     |  2 ++
 target/m68k/m68k-semi.c   |  2 ++
 target/nios2/nios2-semi.c |  2 ++
 tcg/aarch64/tcg-target.h  | 10 ++++++++
 9 files changed, 104 insertions(+), 23 deletions(-)

diff --git a/block.c b/block.c
index d9ac0e07eb..1bf0c813a1 100644
--- a/block.c
+++ b/block.c
@@ -52,7 +52,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if !defined(__DragonFly__) && !defined(CONFIG_IOS)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/block/file-posix.c b/block/file-posix.c
index 9a00d4190a..c8c13ab218 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -41,7 +41,7 @@
 #include "scsi/pr-manager.h"
 #include "scsi/constants.h"
 
-#if defined(__APPLE__) && (__MACH__)
+#if defined(CONFIG_HOST_DEVICE) && defined(__APPLE__) && (__MACH__)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -181,7 +181,16 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0)
+        return 0;
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -252,6 +261,12 @@ static int raw_normalize_devicepath(const char **filename, Error **errp)
 }
 #endif
 
+#if defined(CONFIG_IOS)
+static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
+{
+    return -ENOTSUP; // not supported on iOS
+}
+#else /* CONFIG_IOS */
 /*
  * Get logical block size via ioctl. On success store it in @sector_size_p.
  */
@@ -284,6 +299,7 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
 
     return success ? 0 : -errno;
 }
+#endif /* !CONFIG_IOS */
 
 /**
  * Get physical block size of @fd.
@@ -2309,7 +2325,7 @@ again:
         }
         if (size == 0)
 #endif
-#if defined(__APPLE__) && defined(__MACH__)
+#if !defined(CONFIG_IOS) && defined(__APPLE__) && defined(__MACH__)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -3251,6 +3267,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(CONFIG_HOST_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3543,16 +3561,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3876,6 +3884,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* CONFIG_HOST_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3883,6 +3893,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(CONFIG_HOST_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3890,6 +3901,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* CONFIG_HOST_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/configure b/configure
index 2acc4d1465..a77ac80a03 100755
--- a/configure
+++ b/configure
@@ -519,6 +519,7 @@ fuzzing="no"
 rng_none="no"
 secret_keyring=""
 libdaxctl=""
+host_device_support="yes"
 
 supported_cpu="no"
 supported_os="no"
@@ -635,6 +636,19 @@ EOF
   compile_object
 }
 
+check_ios() {
+  cat > $TMPC <<EOF
+#ifdef __APPLE__
+#import "TargetConditionals.h" 
+#if !TARGET_OS_IPHONE
+#error TARGET_OS_IPHONE not true
+#endif
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
 check_include() {
 cat > $TMPC <<EOF
 #include <$1>
@@ -677,7 +691,11 @@ elif check_define __DragonFly__ ; then
 elif check_define __NetBSD__; then
   targetos='NetBSD'
 elif check_define __APPLE__; then
-  targetos='Darwin'
+  if check_ios ; then
+    targetos='iOS'
+  else
+    targetos='Darwin'
+  fi
 else
   # This is a fatal error, but don't report it yet, because we
   # might be going to just print the --help text, or it might
@@ -883,6 +901,27 @@ Darwin)
   HOST_VARIANT_DIR="darwin"
   supported_os="yes"
 ;;
+iOS)
+  bsd="yes"
+  darwin="yes"
+  ios="yes"
+  hax="yes"
+  hvf="yes"
+  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    QEMU_LDFLAGS="-arch x86_64 $QEMU_LDFLAGS"
+  fi
+  host_device_support="no"
+  audio_drv_list=""
+  audio_possible_drivers=""
+  QEMU_LDFLAGS="-framework CoreFoundation $QEMU_LDFLAGS"
+  # Disable attempts to use ObjectiveC features in os/object.h since they
+  # won't work when we're compiling with gcc as a C compiler.
+  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
+  HOST_VARIANT_DIR="ios"
+  supported_os="yes"
+;;
 SunOS)
   solaris="yes"
   make="${MAKE-gmake}"
@@ -7019,6 +7058,7 @@ echo "fuzzing support   $fuzzing"
 echo "gdb               $gdb_bin"
 echo "rng-none          $rng_none"
 echo "Linux keyring     $secret_keyring"
+echo "host device support  $host_device_support"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -7089,6 +7129,9 @@ if test "$default_devices" = "yes" ; then
 else
   echo "CONFIG_MINIKCONF_MODE=--allnoconfig" >> $config_host_mak
 fi
+if test "$host_device_support" = "yes" ; then
+  echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
@@ -7138,6 +7181,10 @@ if test "$darwin" = "yes" ; then
   echo "CONFIG_DARWIN=y" >> $config_host_mak
 fi
 
+if test "$ios" = "yes" ; then
+  echo "CONFIG_IOS=y" >> $config_host_mak
+fi
+
 if test "$solaris" = "yes" ; then
   echo "CONFIG_SOLARIS=y" >> $config_host_mak
 fi
diff --git a/net/slirp.c b/net/slirp.c
index 77042e6df7..8413042c09 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -90,7 +90,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -103,7 +103,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -368,7 +368,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -478,7 +478,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -593,7 +593,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             }
         }
     }
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -785,7 +785,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -900,7 +900,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* !defined(_WIN32) && !defined(CONFIG_IOS) */
 
 static int guestfwd_can_read(void *opaque)
 {
diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index 1a62a3a70d..0d721f4b57 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -34,6 +34,12 @@
 
 #ifndef CONFIG_HAS_ENVIRON
 #ifdef __APPLE__
+#include "TargetConditionals.h"
+#if !TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+#define APPLE_USE_CRT_EXTERNS
+#endif
+#endif
+#ifdef APPLE_USE_CRT_EXTERNS
 #include <crt_externs.h>
 #define environ (*_NSGetEnviron())
 #else
diff --git a/target/arm/arm-semi.c b/target/arm/arm-semi.c
index 8718fd0194..f2618e583f 100644
--- a/target/arm/arm-semi.c
+++ b/target/arm/arm-semi.c
@@ -891,6 +891,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
         return clock() / (CLOCKS_PER_SEC / 100);
     case TARGET_SYS_TIME:
         return set_swi_errno(env, time(NULL));
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case TARGET_SYS_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -907,6 +908,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
             unlock_user(s, arg0, 0);
             return ret;
         }
+#endif /* CONFIG_IOS */
     case TARGET_SYS_ERRNO:
         return get_swi_errno(env);
     case TARGET_SYS_GET_CMDLINE:
diff --git a/target/m68k/m68k-semi.c b/target/m68k/m68k-semi.c
index 8e5fbfc8fa..598a1b78a2 100644
--- a/target/m68k/m68k-semi.c
+++ b/target/m68k/m68k-semi.c
@@ -402,6 +402,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -420,6 +421,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             }
         }
         break;
+#endif /* CONFIG_IOS */
     case HOSTED_INIT_SIM:
 #if defined(CONFIG_USER_ONLY)
         {
diff --git a/target/nios2/nios2-semi.c b/target/nios2/nios2-semi.c
index d7a80dd303..bfbaa00bb6 100644
--- a/target/nios2/nios2-semi.c
+++ b/target/nios2/nios2-semi.c
@@ -426,6 +426,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -444,6 +445,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             }
         }
         break;
+#endif
     default:
         qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: unsupported "
                       "semihosting syscall %d\n", nr);
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index 9bc2a5ecbe..298e2d306c 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -149,9 +149,19 @@ typedef enum {
 #define TCG_TARGET_DEFAULT_MO (0)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
+#ifdef __APPLE__
+void sys_icache_invalidate(void *start, size_t len);
+#endif
+
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
+#if defined(__APPLE__)
+    sys_icache_invalidate((char *)start, stop-start);
+#elif defined(__GNUC__)
     __builtin___clear_cache((char *)start, (char *)stop);
+#else
+#error "Missing builtin to flush instruction cache"
+#endif
 }
 
 void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
-- 
2.24.3 (Apple Git-128)

From bd3929e6b39a6d60bbdc72f5d86fc415a196dac7 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 27 Mar 2019 14:47:00 -0700
Subject: [PATCH 2/7] build: Added support for building QEMU as a shared
 library

For building QEMU as a shared lib, it must be loaded as a dylib. This breaks
compatibility with OSX < 10.4.
---
 Makefile        | 21 +++++++++++++++++++++
 Makefile.target | 24 +++++++++++++++++++++++-
 configure       | 28 ++++++++++++++++++++++++----
 qemu-img.c      |  5 +++++
 rules.mak       |  6 ++++++
 5 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/Makefile b/Makefile
index 13dd708c4a..c537a933fa 100644
--- a/Makefile
+++ b/Makefile
@@ -592,6 +592,16 @@ Makefile: $(version-obj-y)
 libqemuutil.a: $(util-obj-y) $(trace-obj-y) $(stub-obj-y)
 libvhost-user.a: $(libvhost-user-obj-y) $(util-obj-y) $(stub-obj-y)
 
+ifdef CONFIG_DARWIN
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.dylib
+else
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.so
+endif
+SOBJS=$(QEMU_IMG_SHARED_LIBRARY)
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS)
+endif
+
 ######################################################################
 
 COMMON_LDADDS = libqemuutil.a
@@ -599,6 +609,11 @@ COMMON_LDADDS = libqemuutil.a
 qemu-img.o: qemu-img-cmds.h
 
 qemu-img$(EXESUF): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+
+$(QEMU_IMG_SHARED_LIBRARY): QEMU_LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_IMG_SHARED_LIBRARY): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 qemu-nbd$(EXESUF): qemu-nbd.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-io$(EXESUF): qemu-io.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-storage-daemon$(EXESUF): qemu-storage-daemon.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(chardev-obj-y) $(io-obj-y) $(qom-obj-y) $(storage-daemon-obj-y) $(COMMON_LDADDS)
@@ -764,6 +779,7 @@ clean: recurse-clean
 		-exec rm {} +
 	rm -f $(edk2-decompressed)
 	rm -f $(filter-out %.tlb,$(TOOLS)) $(HELPERS-y) TAGS cscope.* *.pod *~ */*~
+	rm -f $(SOBJS)
 	rm -f fsdev/*.pod scsi/*.pod
 	rm -f qemu-img-cmds.h
 	rm -f ui/shader/*-vert.h ui/shader/*-frag.h
@@ -930,6 +946,11 @@ install: all $(if $(BUILD_DOCS),install-doc) \
 ifneq ($(TOOLS),)
 	$(call install-prog,$(TOOLS),$(DESTDIR)$(bindir))
 endif
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+endif
 ifneq ($(CONFIG_MODULES),)
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_moddir)"
 	for s in $(modules-m:.mo=$(DSOSUF)); do \
diff --git a/Makefile.target b/Makefile.target
index ffa2657269..3397225653 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -37,6 +37,14 @@ endif
 endif
 
 PROGS=$(QEMU_PROG) $(QEMU_PROGW)
+
+ifdef CONFIG_DARWIN
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).dylib
+else
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).so
+endif
+SOBJS=$(QEMU_SHARED_LIBRARY)
+
 STPFILES=
 
 config-target.h: config-target.h-timestamp
@@ -98,7 +106,11 @@ stap:
 endif
 .PHONY: stap
 
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS) stap
+else
 all: $(PROGS) stap
+endif
 
 # Dummy command so that make thinks it has done something
 	@true
@@ -222,6 +234,10 @@ ifdef CONFIG_DARWIN
 	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
 endif
 
+$(QEMU_SHARED_LIBRARY): QEMU_LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_SHARED_LIBRARY): $(all-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
 	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"GEN","$(TARGET_DIR)$@")
 
@@ -232,7 +248,7 @@ hmp-commands-info.h: $(SRC_PATH)/hmp-commands-info.hx $(SRC_PATH)/scripts/hxtool
 	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"GEN","$(TARGET_DIR)$@")
 
 clean: clean-target
-	rm -f *.a *~ $(PROGS)
+	rm -f *.a *~ $(PROGS) $(SOBJS)
 	rm -f $(shell find . -name '*.[od]')
 	rm -f hmp-commands.h gdbstub-xml.c
 	rm -f trace/generated-helpers.c trace/generated-helpers.c-timestamp
@@ -257,9 +273,15 @@ $(QEMU_PROG_FUZZ): config-devices.mak $(all-obj-y) $(COMMON_LDADDS) $(fuzz-obj-y
 endif
 
 install: all
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+else
 ifneq ($(PROGS),)
 	$(call install-prog,$(PROGS),$(DESTDIR)$(bindir))
 endif
+endif
 ifdef CONFIG_TRACE_SYSTEMTAP
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
 	$(INSTALL_DATA) $(QEMU_PROG).stp-installed "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp"
diff --git a/configure b/configure
index a77ac80a03..ba0fe82a01 100755
--- a/configure
+++ b/configure
@@ -520,6 +520,7 @@ rng_none="no"
 secret_keyring=""
 libdaxctl=""
 host_device_support="yes"
+shared_lib="no"
 
 supported_cpu="no"
 supported_os="no"
@@ -885,7 +886,8 @@ Darwin)
   darwin="yes"
   hax="yes"
   hvf="yes"
-  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  DSOSUF=".dylib"
+  LDFLAGS_SHARED="-dynamiclib -undefined dynamic_lookup"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
     QEMU_LDFLAGS="-arch x86_64 $QEMU_LDFLAGS"
@@ -893,8 +895,8 @@ Darwin)
   cocoa="yes"
   audio_drv_list="coreaudio try-sdl"
   audio_possible_drivers="coreaudio sdl"
-  QEMU_LDFLAGS="-framework CoreFoundation -framework IOKit $QEMU_LDFLAGS"
-  libs_softmmu="-F/System/Library/Frameworks -framework Cocoa -framework IOKit $libs_softmmu"
+  QEMU_LDFLAGS="-framework CoreFoundation -framework IOKit -lresolv $QEMU_LDFLAGS"
+  libs_softmmu="-F/System/Library/Frameworks -framework IOKit $libs_softmmu"
   # Disable attempts to use ObjectiveC features in os/object.h since they
   # won't work when we're compiling with gcc as a C compiler.
   QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
@@ -907,7 +909,8 @@ iOS)
   ios="yes"
   hax="yes"
   hvf="yes"
-  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  DSOSUF=".dylib"
+  LDFLAGS_SHARED="-dynamiclib"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
     QEMU_LDFLAGS="-arch x86_64 $QEMU_LDFLAGS"
@@ -1679,6 +1682,17 @@ for opt do
   ;;
   --disable-libdaxctl) libdaxctl=no
   ;;
+  --enable-shared-lib)
+      shared_lib=yes
+      want_tools=no
+      cocoa=no
+      gtk=no
+      sdl=no
+      QEMU_CFLAGS="$QEMU_CFLAGS -fPIC"
+      DSOSUF="-module$DSOSUF" # fix for make 2.81 not building target order correctly
+  ;;
+  --disable-shared-lib) shared_lib=no
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1871,6 +1885,7 @@ Advanced options (experts only):
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
   --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
+  --enable-shared-lib      build QEMU as a shared library instead of an application
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available:
@@ -2404,6 +2419,7 @@ if test "$cocoa" = "yes"; then
     if test "$gtk" = "yes"; then
         error_exit "Cocoa and GTK UIs cannot both be enabled at once"
     fi
+    libs_softmmu="$libs_softmmu -framework Cocoa"
     gtk=no
     sdl=no
 fi
@@ -7059,6 +7075,7 @@ echo "gdb               $gdb_bin"
 echo "rng-none          $rng_none"
 echo "Linux keyring     $secret_keyring"
 echo "host device support  $host_device_support"
+echo "build shared lib  $shared_lib"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -7132,6 +7149,9 @@ fi
 if test "$host_device_support" = "yes" ; then
   echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
 fi
+if test "$shared_lib" = "yes" ; then
+  echo "CONFIG_SHARED_LIB=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
diff --git a/qemu-img.c b/qemu-img.c
index 5308773811..8788e5dde0 100644
--- a/qemu-img.c
+++ b/qemu-img.c
@@ -50,6 +50,11 @@
 #include "crypto/init.h"
 #include "trace/control.h"
 
+#if defined(CONFIG_SHARED_LIB)
+#undef main
+#define main qemu_img_main
+#endif
+
 #define QEMU_IMG_VERSION "qemu-img version " QEMU_FULL_VERSION \
                           "\n" QEMU_COPYRIGHT "\n"
 
diff --git a/rules.mak b/rules.mak
index 694865b63e..906b2e134c 100644
--- a/rules.mak
+++ b/rules.mak
@@ -154,6 +154,12 @@ define install-prog
 	$(if $(STRIP),$(STRIP) $(foreach T,$1,"$2/$(notdir $T)"),)
 endef
 
+# install-so list, dir
+define install-so
+    $(INSTALL_DIR) "$2"
+    $(INSTALL_LIB) $1 "$2"
+endef
+
 # find-in-path
 # Usage: $(call find-in-path, prog)
 # Looks in the PATH if the argument contains no slash, else only considers one
-- 
2.24.3 (Apple Git-128)

From 7b72c6b9c7c88f9c4c3cfa6357ea5762fabb8a1b Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Fri, 29 Mar 2019 15:41:07 -0700
Subject: [PATCH 3/7] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is also unsupported (even worse, it fails silently, see: https://openradar.appspot.com/13002712 )
---
 .gitmodules               |  3 +++
 Makefile                  | 10 ++++++++++
 configure                 | 27 +++++++++++++++++++++++++--
 libucontext               |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 5 files changed, 48 insertions(+), 2 deletions(-)
 create mode 160000 libucontext

diff --git a/.gitmodules b/.gitmodules
index 9c0501a4d4..4d140cda28 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -58,3 +58,6 @@
 [submodule "roms/qboot"]
 	path = roms/qboot
 	url = https://github.com/bonzini/qboot
+[submodule "libucontext"]
+	path = libucontext
+	url = https://github.com/utmapp/libucontext.git
diff --git a/Makefile b/Makefile
index c537a933fa..a49ee7d406 100644
--- a/Makefile
+++ b/Makefile
@@ -550,6 +550,9 @@ CAP_CFLAGS += -DCAPSTONE_HAS_ARM64
 CAP_CFLAGS += -DCAPSTONE_HAS_POWERPC
 CAP_CFLAGS += -DCAPSTONE_HAS_X86
 
+LIBUCONTEXT_CFLAGS = $(CFLAGS) $(QEMU_CFLAGS)
+LIBUCONTEXT_CFLAGS += -DCUSTOM_IMPL
+
 .PHONY: capstone/all
 capstone/all: .git-submodule-status
 	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/capstone CAPSTONE_SHARED=no BUILDDIR="$(BUILD_DIR)/capstone" CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" CFLAGS="$(CAP_CFLAGS)" $(SUBDIR_MAKEFLAGS) $(BUILD_DIR)/capstone/$(LIBCAPSTONE))
@@ -562,6 +565,13 @@ slirp/all: .git-submodule-status
 		CC="$(CC)" AR="$(AR)" 	LD="$(LD)" RANLIB="$(RANLIB)"	\
 		CFLAGS="$(QEMU_CFLAGS) $(CFLAGS)" LDFLAGS="$(QEMU_LDFLAGS)")
 
+.PHONY: libucontext/all
+libucontext/all: .git-submodule-status
+	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/libucontext \
+		ARCH="$(ARCH)" BUILD_DIR="$(BUILD_DIR)/libucontext" \
+		CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" \
+		CFLAGS="$(LIBUCONTEXT_CFLAGS)" LDFLAGS="$(QEMU_LDFLAGS)")
+
 $(filter %/all, $(TARGET_DIRS_RULES)): libqemuutil.a $(common-obj-y) \
 	$(qom-obj-y)
 
diff --git a/configure b/configure
index ba0fe82a01..3564a946a6 100755
--- a/configure
+++ b/configure
@@ -1870,7 +1870,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --gcov=GCOV              use specified gcov [$gcov_tool]
   --disable-blobs          disable installing provided firmware blobs
@@ -5670,6 +5670,8 @@ if test "$coroutine" = ""; then
     coroutine=win32
   elif test "$ucontext_works" = "yes"; then
     coroutine=ucontext
+  elif test "$ios" = "yes"; then
+    coroutine=libucontext
   else
     coroutine=sigaltstack
   fi
@@ -5693,12 +5695,29 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} libucontext"
+  mkdir -p libucontext
+  QEMU_CFLAGS="$QEMU_CFLAGS -I\$(SRC_PATH)/libucontext/include"
+  LIBS="-L\$(BUILD_DIR)/libucontext -lucontext $LIBS"
+  ;;
+esac
+
+if test "$coroutine" == "libucontext"; then
+  coroutine_impl=ucontext
+else
+  coroutine_impl=$coroutine
+fi
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -7705,7 +7724,7 @@ if test "$rbd" = "yes" ; then
   echo "RBD_LIBS=$rbd_libs" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -8567,6 +8586,10 @@ fi
 if [ "$capstone" = "git" -o "$capstone" = "internal" ]; then
   echo "config-host.h: capstone/all" >> $config_host_mak
 fi
+if [ "$coroutine" = "libucontext" ]; then
+  echo "config-host.h: libucontext/all" >> $config_host_mak
+  echo "CONFIG_LIBUCONTEXT=y" >> $config_host_mak
+fi
 if test -n "$LIBCAPSTONE"; then
   echo "LIBCAPSTONE=$LIBCAPSTONE" >> $config_host_mak
 fi
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 904b375192..1e1dd43512 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H
-- 
2.24.3 (Apple Git-128)

From 75a3837dfbe4fae47b38bbbff4ec16a12926034c Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Sun, 23 Feb 2020 22:13:35 -0800
Subject: [PATCH 4/7] tcg: implement bulletproof JIT

On iOS, we cannot allocate RWX pages without special entitlements. As a
workaround, we can a RX region and then mirror map it to a separate RX
region. Then we can write to one region and execute from the other one.

To better keep track of pointers to RW/RX memory, we mark any tcg_insn_unit
pointers as `const` if they will never be written to. We also define a new
macro `TCG_CODE_PTR_RW` that returns a pointer to RW memory. Only the
difference between the two regions is stored in the TCG context.

To ensure cache coherency, we flush the data cache in the RW mapping and
then invalidate the instruction cache in the RX mapping (where applicable).
Because data cache flush is OS defined on some architectures, we do not
provide implementations for non iOS platforms (ARM/x86).
---
 accel/tcg/cpu-exec.c         |  7 +++-
 accel/tcg/translate-all.c    | 77 ++++++++++++++++++++++++++++++++++--
 configure                    |  1 +
 docs/devel/ios.rst           | 40 +++++++++++++++++++
 include/exec/exec-all.h      |  7 ++++
 include/tcg/tcg.h            | 18 +++++++--
 tcg/aarch64/tcg-target.h     | 13 +++++-
 tcg/aarch64/tcg-target.inc.c | 48 +++++++++++++---------
 tcg/arm/tcg-target.h         |  9 ++++-
 tcg/arm/tcg-target.inc.c     | 33 +++++++++-------
 tcg/i386/tcg-target.h        | 24 ++++++++++-
 tcg/i386/tcg-target.inc.c    | 28 ++++++-------
 tcg/mips/tcg-target.h        |  8 +++-
 tcg/mips/tcg-target.inc.c    | 62 +++++++++++++++++------------
 tcg/ppc/tcg-target.h         |  8 +++-
 tcg/ppc/tcg-target.inc.c     | 51 +++++++++++++++---------
 tcg/riscv/tcg-target.h       |  9 ++++-
 tcg/riscv/tcg-target.inc.c   | 51 +++++++++++++-----------
 tcg/s390/tcg-target.h        | 13 +++++-
 tcg/s390/tcg-target.inc.c    | 25 ++++++------
 tcg/sparc/tcg-target.h       |  8 +++-
 tcg/sparc/tcg-target.inc.c   | 29 ++++++++------
 tcg/tcg-ldst.inc.c           |  2 +-
 tcg/tcg-pool.inc.c           |  9 +++--
 tcg/tcg.c                    | 60 ++++++++++++++++++----------
 tcg/tci/tcg-target.h         | 13 +++++-
 tcg/tci/tcg-target.inc.c     |  8 ++--
 27 files changed, 478 insertions(+), 183 deletions(-)
 create mode 100644 docs/devel/ios.rst

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 66d38f9d85..39173ffed6 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -348,7 +348,12 @@ void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr)
     if (TCG_TARGET_HAS_direct_jump) {
         uintptr_t offset = tb->jmp_target_arg[n];
         uintptr_t tc_ptr = (uintptr_t)tb->tc.ptr;
-        tb_target_set_jmp_target(tc_ptr, tc_ptr + offset, addr);
+#if defined(CONFIG_IOS_JIT)
+        uintptr_t wr_addr = tc_ptr + offset + tb->code_rw_mirror_diff;
+#else
+        uintptr_t wr_addr = tc_ptr + offset;
+#endif
+        tb_target_set_jmp_target(tc_ptr, tc_ptr + offset, addr, wr_addr);
     } else {
         tb->jmp_target_arg[n] = addr;
     }
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 2d83013633..039c66698e 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -59,6 +59,22 @@
 #include "sysemu/cpus.h"
 #include "sysemu/tcg.h"
 
+#if defined(CONFIG_IOS_JIT)
+#include <mach/mach.h>
+extern kern_return_t mach_vm_remap(vm_map_t target_task,
+                                   mach_vm_address_t *target_address,
+                                   mach_vm_size_t size,
+                                   mach_vm_offset_t mask,
+                                   int flags,
+                                   vm_map_t src_task,
+                                   mach_vm_address_t src_address,
+                                   boolean_t copy,
+                                   vm_prot_t *cur_protection,
+                                   vm_prot_t *max_protection,
+                                   vm_inherit_t inheritance
+                                  );
+#endif
+
 /* #define DEBUG_TB_INVALIDATE */
 /* #define DEBUG_TB_FLUSH */
 /* make various TB consistency checks */
@@ -301,10 +317,12 @@ static target_long decode_sleb128(uint8_t **pp)
 
 static int encode_search(TranslationBlock *tb, uint8_t *block)
 {
-    uint8_t *highwater = tcg_ctx->code_gen_highwater;
-    uint8_t *p = block;
+    uint8_t *highwater;
+    uint8_t *p;
     int i, j, n;
 
+    highwater = (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, tcg_ctx->code_gen_highwater);
+    p = (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, block);
     for (i = 0, n = tb->icount; i < n; ++i) {
         target_ulong prev;
 
@@ -328,7 +346,7 @@ static int encode_search(TranslationBlock *tb, uint8_t *block)
         }
     }
 
-    return p - block;
+    return p - (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, block);
 }
 
 /* The cpu state corresponding to 'searched_pc' is restored.
@@ -1066,7 +1084,11 @@ static inline void *alloc_code_gen_buffer(void)
 #else
 static inline void *alloc_code_gen_buffer(void)
 {
+#if defined(CONFIG_IOS_JIT)
+    int prot = PROT_READ | PROT_EXEC;
+#else
     int prot = PROT_WRITE | PROT_READ | PROT_EXEC;
+#endif
     int flags = MAP_PRIVATE | MAP_ANONYMOUS;
     size_t size = tcg_ctx->code_gen_buffer_size;
     void *buf;
@@ -1117,6 +1139,39 @@ static inline void *alloc_code_gen_buffer(void)
 }
 #endif /* USE_STATIC_CODE_GEN_BUFFER, WIN32, POSIX */
 
+#if defined(CONFIG_IOS_JIT)
+static inline void *alloc_jit_rw_mirror(void *base, size_t size)
+{
+    kern_return_t ret;
+    mach_vm_address_t mirror;
+    vm_prot_t cur_prot, max_prot;
+
+    mirror = 0;
+    ret = mach_vm_remap(mach_task_self(),
+                        &mirror,
+                        size,
+                        0,
+                        VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR,
+                        mach_task_self(),
+                        (mach_vm_address_t)base,
+                        false,
+                        &cur_prot,
+                        &max_prot,
+                        VM_INHERIT_NONE
+                       );
+    if (ret != KERN_SUCCESS) {
+        return NULL;
+    }
+
+    if (mprotect((void *)mirror, size, PROT_READ | PROT_WRITE) != 0) {
+        munmap((void *)mirror, size);
+        return NULL;
+    }
+
+    return (void *)mirror;
+}
+#endif /* CONFIG_IOS_JIT */
+
 static inline void code_gen_alloc(size_t tb_size)
 {
     tcg_ctx->code_gen_buffer_size = size_code_gen_buffer(tb_size);
@@ -1125,6 +1180,19 @@ static inline void code_gen_alloc(size_t tb_size)
         fprintf(stderr, "Could not allocate dynamic translator buffer\n");
         exit(1);
     }
+#if defined(CONFIG_IOS_JIT)
+    void *mirror;
+
+    /* For iOS JIT we need a mirror mapping for code execution */
+    mirror = alloc_jit_rw_mirror(tcg_ctx->code_gen_buffer,
+                                 tcg_ctx->code_gen_buffer_size
+                                );
+    if (mirror == NULL) {
+        fprintf(stderr, "Could not remap code buffer mirror\n");
+        exit(1);
+    }
+    tcg_ctx->code_rw_mirror_diff = mirror - tcg_ctx->code_gen_buffer;
+#endif /* CONFIG_IOS_JIT */
 }
 
 static bool tb_cmp(const void *ap, const void *bp)
@@ -1720,6 +1788,9 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
         cpu_loop_exit(cpu);
     }
 
+#if defined(CONFIG_IOS_JIT)
+    tb->code_rw_mirror_diff = tcg_ctx->code_rw_mirror_diff;
+#endif
     gen_code_buf = tcg_ctx->code_gen_ptr;
     tb->tc.ptr = gen_code_buf;
     tb->pc = pc;
diff --git a/configure b/configure
index 3564a946a6..0ab4633fbd 100755
--- a/configure
+++ b/configure
@@ -7222,6 +7222,7 @@ fi
 
 if test "$ios" = "yes" ; then
   echo "CONFIG_IOS=y" >> $config_host_mak
+  echo "CONFIG_IOS_JIT=y" >> $config_host_mak
 fi
 
 if test "$solaris" = "yes" ; then
diff --git a/docs/devel/ios.rst b/docs/devel/ios.rst
new file mode 100644
index 0000000000..b0fda060ab
--- /dev/null
+++ b/docs/devel/ios.rst
@@ -0,0 +1,40 @@
+===========
+iOS Support
+===========
+
+To run qemu on the iOS platform, some modifications were required. Most of the 
+modifications are conditioned on the ``CONFIG_IOS`` and ``CONFIG_IOS_JIT`` 
+configuration variables.
+
+Build support
+-------------
+
+For the code to compile, certain changes in the block driver and the slirp 
+driver had to be made. There is no ``system()`` call, so code requiring it had 
+to be disabled.
+
+``ucontext`` support is broken on iOS. The implementation from ``libucontext`` 
+is used instead.
+
+Because ``fork()`` is not allowed on iOS apps, the option to build qemu and the 
+utilities as shared libraries is added. Note that because qemu does not perform 
+resource cleanup in most cases (open files, allocated memory, etc), it is 
+advisable that the user implements a proxy layer for syscalls so resources can 
+be kept track by the app that uses qemu as a shared library.
+
+JIT support
+-----------
+
+On iOS, allocating RWX pages require special entitlements not usually granted to
+apps. However, it is possible to use `bulletproof JIT`_ with a development 
+certificate. This means that we need to allocate one chunk of memory with RX 
+permissions and then mirror map the same memory with RW permissions. We generate
+code to the mirror mapping and execute the original mapping.
+
+With ``CONFIG_IOS_JIT`` defined, we store inside the TCG context the difference 
+between the two mappings. Then, we make sure that any writes to JIT memory is 
+done to the pointer + the difference (in order to get a pointer to the mirror 
+mapped space). Additionally, we make sure to flush the data cache before we 
+invalidate the instruction cache so the changes are seen in both mappings.
+
+.. _bulletproof JIT: https://www.blackhat.com/docs/us-16/materials/us-16-Krstic.pdf
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index 3cf88272df..8d3a52fb81 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -483,6 +483,13 @@ struct TranslationBlock {
     uintptr_t jmp_list_head;
     uintptr_t jmp_list_next[2];
     uintptr_t jmp_dest[2];
+
+#if defined(CONFIG_IOS_JIT)
+    /* Store difference to writable mirror
+     * We need this when patching the jump instructions
+     */
+    ptrdiff_t code_rw_mirror_diff;
+#endif
 };
 
 extern bool parallel_cpus;
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index e63450a893..cda957d729 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -261,7 +261,7 @@ struct TCGLabel {
     unsigned refs : 16;
     union {
         uintptr_t value;
-        tcg_insn_unit *value_ptr;
+        const tcg_insn_unit *value_ptr;
     } u;
     QSIMPLEQ_HEAD(, TCGRelocation) relocs;
     QSIMPLEQ_ENTRY(TCGLabel) next;
@@ -593,7 +593,7 @@ struct TCGContext {
     int nb_ops;
 
     /* goto_tb support */
-    tcg_insn_unit *code_buf;
+    const tcg_insn_unit *code_buf;
     uint16_t *tb_jmp_reset_offset; /* tb->jmp_reset_offset */
     uintptr_t *tb_jmp_insn_offset; /* tb->jmp_target_arg if direct_jump */
     uintptr_t *tb_jmp_target_addr; /* tb->jmp_target_arg if !direct_jump */
@@ -627,6 +627,9 @@ struct TCGContext {
     size_t code_gen_buffer_size;
     void *code_gen_ptr;
     void *data_gen_ptr;
+#if defined(CONFIG_IOS_JIT)
+    ptrdiff_t code_rw_mirror_diff;
+#endif
 
     /* Threshold to flush the translated code buffer.  */
     void *code_gen_highwater;
@@ -677,6 +680,13 @@ struct TCGContext {
     target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];
 };
 
+#if defined(CONFIG_IOS_JIT)
+# define TCG_CODE_PTR_RW(s, code_ptr) \
+    (tcg_insn_unit *)((uintptr_t)(code_ptr) + (s)->code_rw_mirror_diff)
+#else
+# define TCG_CODE_PTR_RW(s, code_ptr) (code_ptr)
+#endif
+
 extern TCGContext tcg_init_ctx;
 extern __thread TCGContext *tcg_ctx;
 extern TCGv_env cpu_env;
@@ -1090,7 +1100,7 @@ static inline TCGLabel *arg_label(TCGArg i)
  * correct result.
  */
 
-static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)
+static inline ptrdiff_t tcg_ptr_byte_diff(const void *a, const void *b)
 {
     return a - b;
 }
@@ -1104,7 +1114,7 @@ static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)
  * to the destination address.
  */
 
-static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, void *target)
+static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, const void *target)
 {
     return tcg_ptr_byte_diff(target, s->code_ptr);
 }
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index 298e2d306c..a12f66197c 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -151,6 +151,7 @@ typedef enum {
 
 #ifdef __APPLE__
 void sys_icache_invalidate(void *start, size_t len);
+void sys_dcache_flush(void *start, size_t len);
 #endif
 
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
@@ -164,7 +165,17 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 #endif
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#if defined(__APPLE__)
+    sys_dcache_flush((char *)start, stop-start);
+#else
+#error "Missing function to flush data cache"
+#endif
+}
+#endif
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/aarch64/tcg-target.inc.c b/tcg/aarch64/tcg-target.inc.c
index 760b0e742d..fac05f6317 100644
--- a/tcg/aarch64/tcg-target.inc.c
+++ b/tcg/aarch64/tcg-target.inc.c
@@ -78,38 +78,44 @@ static const int tcg_target_call_oarg_regs[1] = {
 #define TCG_REG_GUEST_BASE TCG_REG_X28
 #endif
 
-static inline bool reloc_pc26(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc26(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
         /* read instruction, mask away previous PC_REL26 parameter contents,
            set the proper offset, then write back the instruction. */
-        *code_ptr = deposit32(*code_ptr, 0, 26, offset);
+        *TCG_CODE_PTR_RW(s, code_ptr) =
+            deposit32(*TCG_CODE_PTR_RW(s, code_ptr), 0, 26, offset);
         return true;
     }
     return false;
 }
 
-static inline bool reloc_pc19(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc19(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - code_ptr;
     if (offset == sextract64(offset, 0, 19)) {
-        *code_ptr = deposit32(*code_ptr, 5, 19, offset);
+        *TCG_CODE_PTR_RW(s, code_ptr) =
+            deposit32(*TCG_CODE_PTR_RW(s, code_ptr), 5, 19, offset);
         return true;
     }
     return false;
 }
 
-static inline bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static inline bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                                intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(addend == 0);
     switch (type) {
     case R_AARCH64_JUMP26:
     case R_AARCH64_CALL26:
-        return reloc_pc26(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc26(s, code_ptr, (tcg_insn_unit *)value);
     case R_AARCH64_CONDBR19:
-        return reloc_pc19(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc19(s, code_ptr, (tcg_insn_unit *)value);
     default:
         g_assert_not_reached();
     }
@@ -1309,14 +1315,14 @@ static void tcg_out_cmp(TCGContext *s, TCGType ext, TCGReg a,
     }
 }
 
-static inline void tcg_out_goto(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     tcg_debug_assert(offset == sextract64(offset, 0, 26));
     tcg_out_insn(s, 3206, B, offset);
 }
 
-static inline void tcg_out_goto_long(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto_long(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
@@ -1332,7 +1338,7 @@ static inline void tcg_out_callr(TCGContext *s, TCGReg reg)
     tcg_out_insn(s, 3207, BLR, reg);
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
@@ -1344,7 +1350,7 @@ static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     tcg_insn_unit i1, i2;
     TCGType rt = TCG_TYPE_I64;
@@ -1365,7 +1371,10 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
         i2 = I3401_ADDI | rt << 31 | (addr & 0xfff) << 10 | rd << 5 | rd;
     }
     pair = (uint64_t)i2 << 32 | i1;
-    atomic_set((uint64_t *)jmp_addr, pair);
+    atomic_set((uint64_t *)wr_addr, pair);
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 8);
 }
 
@@ -1571,7 +1580,7 @@ static void * const qemu_st_helpers[16] = {
     [MO_BEQ]  = helper_be_stq_mmu,
 };
 
-static inline void tcg_out_adr(TCGContext *s, TCGReg rd, void *target)
+static inline void tcg_out_adr(TCGContext *s, TCGReg rd, const void *target)
 {
     ptrdiff_t offset = tcg_pcrel_diff(s, target);
     tcg_debug_assert(offset == sextract64(offset, 0, 21));
@@ -1584,7 +1593,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     MemOp size = opc & MO_SIZE;
 
-    if (!reloc_pc19(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc19(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1609,7 +1618,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     MemOp size = opc & MO_SIZE;
 
-    if (!reloc_pc19(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc19(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1625,7 +1634,8 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
 
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGType ext, TCGReg data_reg, TCGReg addr_reg,
-                                tcg_insn_unit *raddr, tcg_insn_unit *label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1852,7 +1862,7 @@ static void tcg_out_qemu_st(TCGContext *s, TCGReg data_reg, TCGReg addr_reg,
 #endif /* CONFIG_SOFTMMU */
 }
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg args[TCG_MAX_OP_ARGS],
@@ -2919,11 +2929,11 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_insn(s, 3207, RET, TCG_REG_LR);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
diff --git a/tcg/arm/tcg-target.h b/tcg/arm/tcg-target.h
index 17e771374d..d8d7e7e239 100644
--- a/tcg/arm/tcg-target.h
+++ b/tcg/arm/tcg-target.h
@@ -139,8 +139,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     __builtin___clear_cache((char *) start, (char *) stop);
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* not defined -- call should be eliminated at compile time */
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/arm/tcg-target.inc.c b/tcg/arm/tcg-target.inc.c
index 6aa7757aac..8547aaca1e 100644
--- a/tcg/arm/tcg-target.inc.c
+++ b/tcg/arm/tcg-target.inc.c
@@ -187,17 +187,22 @@ static const uint8_t tcg_cond_to_arm_cond[] = {
     [TCG_COND_GTU] = COND_HI,
 };
 
-static inline bool reloc_pc24(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc24(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = (tcg_ptr_byte_diff(target, code_ptr) - 8) >> 2;
     if (offset == sextract32(offset, 0, 24)) {
-        *code_ptr = (*code_ptr & ~0xffffff) | (offset & 0xffffff);
+        *TCG_CODE_PTR_RW(s, code_ptr) = 
+            (*TCG_CODE_PTR_RW(s, code_ptr) & ~0xffffff) | (offset & 0xffffff);
         return true;
     }
     return false;
 }
 
-static inline bool reloc_pc13(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc13(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = tcg_ptr_byte_diff(target, code_ptr) - 8;
 
@@ -209,21 +214,21 @@ static inline bool reloc_pc13(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
         }
         insn = deposit32(insn, 23, 1, u);
         insn = deposit32(insn, 0, 12, offset);
-        *code_ptr = insn;
+        *TCG_CODE_PTR_RW(s, code_ptr) = insn;
         return true;
     }
     return false;
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(addend == 0);
 
     if (type == R_ARM_PC24) {
-        return reloc_pc24(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc24(s, code_ptr, (tcg_insn_unit *)value);
     } else if (type == R_ARM_PC13) {
-        return reloc_pc13(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc13(s, code_ptr, (tcg_insn_unit *)value);
     } else {
         g_assert_not_reached();
     }
@@ -1022,7 +1027,7 @@ static inline void tcg_out_st8(TCGContext *s, int cond,
  * with the code buffer limited to 16MB we wouldn't need the long case.
  * But we also use it for the tail-call to the qemu_ld/st helpers, which does.
  */
-static void tcg_out_goto(TCGContext *s, int cond, tcg_insn_unit *addr)
+static void tcg_out_goto(TCGContext *s, int cond, const tcg_insn_unit *addr)
 {
     intptr_t addri = (intptr_t)addr;
     ptrdiff_t disp = tcg_pcrel_diff(s, addr);
@@ -1036,7 +1041,7 @@ static void tcg_out_goto(TCGContext *s, int cond, tcg_insn_unit *addr)
 
 /* The call case is mostly used for helpers - so it's not unreasonable
  * for them to be beyond branch range */
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *addr)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *addr)
 {
     intptr_t addri = (intptr_t)addr;
     ptrdiff_t disp = tcg_pcrel_diff(s, addr);
@@ -1329,7 +1334,7 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,
    helper code.  */
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg datalo, TCGReg datahi, TCGReg addrlo,
-                                TCGReg addrhi, tcg_insn_unit *raddr,
+                                TCGReg addrhi, const tcg_insn_unit *raddr,
                                 tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
@@ -1351,7 +1356,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     void *func;
 
-    if (!reloc_pc24(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc24(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1414,7 +1419,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!reloc_pc24(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc24(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -2258,11 +2263,11 @@ static inline void tcg_out_movi(TCGContext *s, TCGType type,
     tcg_out_movi32(s, COND_AL, ret, arg);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = INSN_NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = INSN_NOP;
     }
 }
 
diff --git a/tcg/i386/tcg-target.h b/tcg/i386/tcg-target.h
index 99ac1e3958..11860c64c8 100644
--- a/tcg/i386/tcg-target.h
+++ b/tcg/i386/tcg-target.h
@@ -207,16 +207,36 @@ extern bool have_avx2;
 #define TCG_TARGET_extract_i64_valid(ofs, len) \
     (((ofs) == 8 && (len) == 8) || ((ofs) + (len)) == 32)
 
+#ifdef __APPLE__
+void sys_dcache_flush(void *start, size_t len);
+#endif
+
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#if defined(__APPLE__)
+    //sys_dcache_flush((char *)start, stop-start);
+#else
+#error "Missing function to flush data cache"
+#endif
+}
+#endif
+
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
-    atomic_set((int32_t *)jmp_addr, addr - (jmp_addr + 4));
+    atomic_set((int32_t *)wr_addr, addr - (jmp_addr + 4));
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    /* we do need to flush mirror dcache */
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 /* This defines the natural memory order supported by this
diff --git a/tcg/i386/tcg-target.inc.c b/tcg/i386/tcg-target.inc.c
index ae0228238b..b4d04d638e 100644
--- a/tcg/i386/tcg-target.inc.c
+++ b/tcg/i386/tcg-target.inc.c
@@ -165,9 +165,9 @@ static bool have_lzcnt;
 # define have_lzcnt 0
 #endif
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     value += addend;
@@ -179,14 +179,14 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         }
         /* FALLTHRU */
     case R_386_32:
-        tcg_patch32(code_ptr, value);
+        tcg_patch32(s, code_ptr, value);
         break;
     case R_386_PC8:
         value -= (uintptr_t)code_ptr;
         if (value != (int8_t)value) {
             return false;
         }
-        tcg_patch8(code_ptr, value);
+        tcg_patch8(s, code_ptr, value);
         break;
     default:
         tcg_abort();
@@ -1602,7 +1602,7 @@ static void tcg_out_clz(TCGContext *s, int rexw, TCGReg dest, TCGReg arg1,
     }
 }
 
-static void tcg_out_branch(TCGContext *s, int call, tcg_insn_unit *dest)
+static void tcg_out_branch(TCGContext *s, int call, const tcg_insn_unit *dest)
 {
     intptr_t disp = tcg_pcrel_diff(s, dest) - 5;
 
@@ -1621,12 +1621,12 @@ static void tcg_out_branch(TCGContext *s, int call, tcg_insn_unit *dest)
     }
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_branch(s, 1, dest);
 }
 
-static void tcg_out_jmp(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_jmp(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_branch(s, 0, dest);
 }
@@ -1785,7 +1785,7 @@ static void add_qemu_ldst_label(TCGContext *s, bool is_ld, bool is_64,
                                 TCGMemOpIdx oi,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                tcg_insn_unit *raddr,
+                                const tcg_insn_unit *raddr,
                                 tcg_insn_unit **label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
@@ -1816,9 +1816,9 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int rexw = (l->type == TCG_TYPE_I64 ? P_REXW : 0);
 
     /* resolve label address */
-    tcg_patch32(label_ptr[0], s->code_ptr - label_ptr[0] - 4);
+    tcg_patch32(s, label_ptr[0], s->code_ptr - label_ptr[0] - 4);
     if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
-        tcg_patch32(label_ptr[1], s->code_ptr - label_ptr[1] - 4);
+        tcg_patch32(s, label_ptr[1], s->code_ptr - label_ptr[1] - 4);
     }
 
     if (TCG_TARGET_REG_BITS == 32) {
@@ -1901,9 +1901,9 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     TCGReg retaddr;
 
     /* resolve label address */
-    tcg_patch32(label_ptr[0], s->code_ptr - label_ptr[0] - 4);
+    tcg_patch32(s, label_ptr[0], s->code_ptr - label_ptr[0] - 4);
     if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
-        tcg_patch32(label_ptr[1], s->code_ptr - label_ptr[1] - 4);
+        tcg_patch32(s, label_ptr[1], s->code_ptr - label_ptr[1] - 4);
     }
 
     if (TCG_TARGET_REG_BITS == 32) {
@@ -3853,9 +3853,9 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_opc(s, OPC_RET, 0, 0, 0);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
-    memset(p, 0x90, count);
+    memset(TCG_CODE_PTR_RW(s, p), 0x90, count);
 }
 
 static void tcg_target_init(TCGContext *s)
diff --git a/tcg/mips/tcg-target.h b/tcg/mips/tcg-target.h
index c6b091d849..80dcba5358 100644
--- a/tcg/mips/tcg-target.h
+++ b/tcg/mips/tcg-target.h
@@ -212,7 +212,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     cacheflush ((void *)start, stop-start, ICACHE);
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/mips/tcg-target.inc.c b/tcg/mips/tcg-target.inc.c
index 4d32ebc1df..7ff31bb5ca 100644
--- a/tcg/mips/tcg-target.inc.c
+++ b/tcg/mips/tcg-target.inc.c
@@ -139,12 +139,13 @@ static const TCGReg tcg_target_call_oarg_regs[2] = {
     TCG_REG_V1
 };
 
-static tcg_insn_unit *tb_ret_addr;
-static tcg_insn_unit *bswap32_addr;
-static tcg_insn_unit *bswap32u_addr;
-static tcg_insn_unit *bswap64_addr;
+static const tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *bswap32_addr;
+static const tcg_insn_unit *bswap32u_addr;
+static const tcg_insn_unit *bswap64_addr;
 
-static inline uint32_t reloc_pc16_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline uint32_t reloc_pc16_val(const tcg_insn_unit *pc,
+                                      const tcg_insn_unit *target)
 {
     /* Let the compiler perform the right-shift as part of the arithmetic.  */
     ptrdiff_t disp = target - (pc + 1);
@@ -152,28 +153,35 @@ static inline uint32_t reloc_pc16_val(tcg_insn_unit *pc, tcg_insn_unit *target)
     return disp & 0xffff;
 }
 
-static inline void reloc_pc16(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline void reloc_pc16(TCGContext *s,
+                              tcg_insn_unit *pc,
+                              const tcg_insn_unit *target)
 {
-    *pc = deposit32(*pc, 0, 16, reloc_pc16_val(pc, target));
+    *TCG_CODE_PTR_RW(s, pc) =
+        deposit32(*TCG_CODE_PTR_RW(s, pc), 0, 16, reloc_pc16_val(pc, target));
 }
 
-static inline uint32_t reloc_26_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline uint32_t reloc_26_val(const tcg_insn_unit *pc,
+                                    const tcg_insn_unit *target)
 {
     tcg_debug_assert((((uintptr_t)pc ^ (uintptr_t)target) & 0xf0000000) == 0);
     return ((uintptr_t)target >> 2) & 0x3ffffff;
 }
 
-static inline void reloc_26(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline void reloc_26(TCGContext *s,
+                            tcg_insn_unit *pc,
+                            const tcg_insn_unit *target)
 {
-    *pc = deposit32(*pc, 0, 26, reloc_26_val(pc, target));
+    *TCG_CODE_PTR_RW(s, pc) =
+        deposit32(*TCG_CODE_PTR_RW(s, pc), 0, 26, reloc_26_val(pc, target));
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(type == R_MIPS_PC16);
     tcg_debug_assert(addend == 0);
-    reloc_pc16(code_ptr, (tcg_insn_unit *)value);
+    reloc_pc16(s, code_ptr, (tcg_insn_unit *)value);
     return true;
 }
 
@@ -519,7 +527,7 @@ static void tcg_out_opc_sa64(TCGContext *s, MIPSInsn opc1, MIPSInsn opc2,
  * Type jump.
  * Returns true if the branch was in range and the insn was emitted.
  */
-static bool tcg_out_opc_jmp(TCGContext *s, MIPSInsn opc, void *target)
+static bool tcg_out_opc_jmp(TCGContext *s, MIPSInsn opc, const void *target)
 {
     uintptr_t dest = (uintptr_t)target;
     uintptr_t from = (uintptr_t)s->code_ptr + 4;
@@ -634,7 +642,7 @@ static inline void tcg_out_bswap16s(TCGContext *s, TCGReg ret, TCGReg arg)
     }
 }
 
-static void tcg_out_bswap_subr(TCGContext *s, tcg_insn_unit *sub)
+static void tcg_out_bswap_subr(TCGContext *s, const tcg_insn_unit *sub)
 {
     bool ok = tcg_out_opc_jmp(s, OPC_JAL, sub);
     tcg_debug_assert(ok);
@@ -928,7 +936,7 @@ static void tcg_out_brcond(TCGContext *s, TCGCond cond, TCGReg arg1,
 
     tcg_out_opc_br(s, b_opc, arg1, arg2);
     if (l->has_value) {
-        reloc_pc16(s->code_ptr - 1, l->u.value_ptr);
+        reloc_pc16(s, s->code_ptr - 1, l->u.value_ptr);
     } else {
         tcg_out_reloc(s, s->code_ptr - 1, R_MIPS_PC16, l, 0);
     }
@@ -1082,7 +1090,7 @@ static void tcg_out_movcond(TCGContext *s, TCGCond cond, TCGReg ret,
     }
 }
 
-static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
+static void tcg_out_call_int(TCGContext *s, const tcg_insn_unit *arg, bool tail)
 {
     /* Note that the ABI requires the called function's address to be
        loaded into T9, even if a direct branch is in range.  */
@@ -1100,7 +1108,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     tcg_out_call_int(s, arg, false);
     tcg_out_nop(s);
@@ -1292,7 +1300,8 @@ static void add_qemu_ldst_label(TCGContext *s, int is_ld, TCGMemOpIdx oi,
                                 TCGType ext,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                void *raddr, tcg_insn_unit *label_ptr[2])
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr[2])
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1318,9 +1327,9 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int i;
 
     /* resolve label address */
-    reloc_pc16(l->label_ptr[0], s->code_ptr);
+    reloc_pc16(s, l->label_ptr[0], s->code_ptr);
     if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        reloc_pc16(l->label_ptr[1], s->code_ptr);
+        reloc_pc16(s, l->label_ptr[1], s->code_ptr);
     }
 
     i = 1;
@@ -1348,7 +1357,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     tcg_out_opc_br(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO);
-    reloc_pc16(s->code_ptr - 1, l->raddr);
+    reloc_pc16(s, s->code_ptr - 1, l->raddr);
 
     /* delay slot */
     if (TCG_TARGET_REG_BITS == 64 && l->type == TCG_TYPE_I32) {
@@ -1368,9 +1377,9 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int i;
 
     /* resolve label address */
-    reloc_pc16(l->label_ptr[0], s->code_ptr);
+    reloc_pc16(s, l->label_ptr[0], s->code_ptr);
     if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        reloc_pc16(l->label_ptr[1], s->code_ptr);
+        reloc_pc16(s, l->label_ptr[1], s->code_ptr);
     }
 
     i = 1;
@@ -2433,7 +2442,7 @@ static void tcg_target_detect_isa(void)
     sigaction(SIGILL, &sa_old, NULL);
 }
 
-static tcg_insn_unit *align_code_ptr(TCGContext *s)
+static const tcg_insn_unit *align_code_ptr(TCGContext *s)
 {
     uintptr_t p = (uintptr_t)s->code_ptr;
     if (p & 15) {
@@ -2660,9 +2669,12 @@ static void tcg_target_init(TCGContext *s)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     atomic_set((uint32_t *)jmp_addr, deposit32(OPC_J, 0, 26, addr >> 2));
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 4);
 }
 
diff --git a/tcg/ppc/tcg-target.h b/tcg/ppc/tcg-target.h
index be5b2901c3..d548eae5bb 100644
--- a/tcg/ppc/tcg-target.h
+++ b/tcg/ppc/tcg-target.h
@@ -175,7 +175,13 @@ extern bool have_vsx;
 #define TCG_TARGET_HAS_cmpsel_vec       0
 
 void flush_icache_range(uintptr_t start, uintptr_t stop);
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #define TCG_TARGET_DEFAULT_MO (0)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
diff --git a/tcg/ppc/tcg-target.inc.c b/tcg/ppc/tcg-target.inc.c
index c8d1e765d9..8de9d124b9 100644
--- a/tcg/ppc/tcg-target.inc.c
+++ b/tcg/ppc/tcg-target.inc.c
@@ -62,7 +62,7 @@
 #define TCG_CT_CONST_MONE 0x2000
 #define TCG_CT_CONST_WSZ  0x4000
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 TCGPowerISA have_isa;
 static bool have_isel;
@@ -184,35 +184,43 @@ static inline bool in_range_b(tcg_target_long target)
     return target == sextract64(target, 0, 26);
 }
 
-static uint32_t reloc_pc24_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static uint32_t reloc_pc24_val(const tcg_insn_unit *pc,
+                               const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     tcg_debug_assert(in_range_b(disp));
     return disp & 0x3fffffc;
 }
 
-static bool reloc_pc24(tcg_insn_unit *pc, tcg_insn_unit *target)
+static bool reloc_pc24(TCGContext *s,
+                       tcg_insn_unit *pc,
+                       const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     if (in_range_b(disp)) {
-        *pc = (*pc & ~0x3fffffc) | (disp & 0x3fffffc);
+        *TCG_CODE_PTR_RW(s, pc) =
+            (*TCG_CODE_PTR_RW(s, pc) & ~0x3fffffc) | (disp & 0x3fffffc);
         return true;
     }
     return false;
 }
 
-static uint16_t reloc_pc14_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static uint16_t reloc_pc14_val(const tcg_insn_unit *pc,
+                               const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     tcg_debug_assert(disp == (int16_t) disp);
     return disp & 0xfffc;
 }
 
-static bool reloc_pc14(tcg_insn_unit *pc, tcg_insn_unit *target)
+static bool reloc_pc14(TCGContext *s,
+                       tcg_insn_unit *pc,
+                       const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     if (disp == (int16_t) disp) {
-        *pc = (*pc & ~0xfffc) | (disp & 0xfffc);
+        *TCG_CODE_PTR_RW(s, pc) =
+            (*TCG_CODE_PTR_RW(s, pc) & ~0xfffc) | (disp & 0xfffc);
         return true;
     }
     return false;
@@ -674,7 +682,7 @@ static const uint32_t tcg_to_isel[] = {
     [TCG_COND_GTU] = ISEL | BC_(7, CR_GT),
 };
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_insn_unit *target;
@@ -686,9 +694,9 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
 
     switch (type) {
     case R_PPC_REL14:
-        return reloc_pc14(code_ptr, target);
+        return reloc_pc14(s, code_ptr, target);
     case R_PPC_REL24:
-        return reloc_pc24(code_ptr, target);
+        return reloc_pc24(s, code_ptr, target);
     case R_PPC_ADDR16:
         /*
          * We are (slightly) abusing this relocation type.  In particular,
@@ -1110,7 +1118,7 @@ static void tcg_out_xori32(TCGContext *s, TCGReg dst, TCGReg src, uint32_t c)
     tcg_out_zori32(s, dst, src, c, XORI, XORIS);
 }
 
-static void tcg_out_b(TCGContext *s, int mask, tcg_insn_unit *target)
+static void tcg_out_b(TCGContext *s, int mask, const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_pcrel_diff(s, target);
     if (in_range_b(disp)) {
@@ -1727,7 +1735,7 @@ static void tcg_out_mb(TCGContext *s, TCGArg a0)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     if (TCG_TARGET_REG_BITS == 64) {
         tcg_insn_unit i1, i2;
@@ -1757,16 +1765,22 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
         /* As per the enclosing if, this is ppc64.  Avoid the _Static_assert
            within atomic_set that would fail to build a ppc32 host.  */
         atomic_set__nocheck((uint64_t *)jmp_addr, pair);
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 8);
     } else {
         intptr_t diff = addr - jmp_addr;
         tcg_debug_assert(in_range_b(diff));
         atomic_set((uint32_t *)jmp_addr, B | (diff & 0x3fffffc));
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 4);
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *target)
 {
 #ifdef _CALL_AIX
     /* Look through the descriptor.  If the branch is in range, and we
@@ -1991,7 +2005,8 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, MemOp opc,
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg datalo_reg, TCGReg datahi_reg,
                                 TCGReg addrlo_reg, TCGReg addrhi_reg,
-                                tcg_insn_unit *raddr, tcg_insn_unit *lptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *lptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -2011,7 +2026,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     TCGReg hi, lo, arg = TCG_REG_R3;
 
-    if (!reloc_pc14(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc14(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -2059,7 +2074,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp s_bits = opc & MO_SIZE;
     TCGReg hi, lo, arg = TCG_REG_R3;
 
-    if (!reloc_pc14(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc14(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -2256,11 +2271,11 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
 #endif
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
diff --git a/tcg/riscv/tcg-target.h b/tcg/riscv/tcg-target.h
index 032439d806..d42b361991 100644
--- a/tcg/riscv/tcg-target.h
+++ b/tcg/riscv/tcg-target.h
@@ -164,8 +164,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     __builtin___clear_cache((char *)start, (char *)stop);
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* not defined -- call should be eliminated at compile time */
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
 #define TCG_TARGET_DEFAULT_MO (0)
 
diff --git a/tcg/riscv/tcg-target.inc.c b/tcg/riscv/tcg-target.inc.c
index 3c11ab8b7a..e35fa78cf0 100644
--- a/tcg/riscv/tcg-target.inc.c
+++ b/tcg/riscv/tcg-target.inc.c
@@ -415,11 +415,11 @@ static void tcg_out_opc_jump(TCGContext *s, RISCVInsn opc,
     tcg_out32(s, encode_uj(opc, rd, imm));
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = encode_i(OPC_ADDI, TCG_REG_ZERO, TCG_REG_ZERO, 0);
+        (TCG_CODE_PTR_RW(s, p))[i] = encode_i(OPC_ADDI, TCG_REG_ZERO, TCG_REG_ZERO, 0);
     }
 }
 
@@ -427,46 +427,52 @@ static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
  * Relocations
  */
 
-static bool reloc_sbimm12(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_sbimm12(TCGContext *s,
+                          tcg_insn_unit *code_ptr,
+                          const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
 
     if (offset == sextreg(offset, 1, 12) << 1) {
-        code_ptr[0] |= encode_sbimm12(offset);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_sbimm12(offset);
         return true;
     }
 
     return false;
 }
 
-static bool reloc_jimm20(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_jimm20(TCGContext *s,
+                         tcg_insn_unit *code_ptr,
+                         const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
 
     if (offset == sextreg(offset, 1, 20) << 1) {
-        code_ptr[0] |= encode_ujimm20(offset);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_ujimm20(offset);
         return true;
     }
 
     return false;
 }
 
-static bool reloc_call(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_call(TCGContext *s,
+                       tcg_insn_unit *code_ptr,
+                       const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
     int32_t lo = sextreg(offset, 0, 12);
     int32_t hi = offset - lo;
 
     if (offset == hi + lo) {
-        code_ptr[0] |= encode_uimm20(hi);
-        code_ptr[1] |= encode_imm12(lo);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_uimm20(hi);
+        (TCG_CODE_PTR_RW(s, code_ptr))[1] |= encode_imm12(lo);
         return true;
     }
 
     return false;
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     uint32_t insn = *code_ptr;
@@ -480,7 +486,7 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         diff = value - (uintptr_t)code_ptr;
         short_jmp = diff == sextreg(diff, 0, 12);
         if (short_jmp) {
-            return reloc_sbimm12(code_ptr, (tcg_insn_unit *)value);
+            return reloc_sbimm12(s, code_ptr, (tcg_insn_unit *)value);
         } else {
             /* Invert the condition */
             insn = insn ^ (1 << 12);
@@ -501,9 +507,9 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         }
         break;
     case R_RISCV_JAL:
-        return reloc_jimm20(code_ptr, (tcg_insn_unit *)value);
+        return reloc_jimm20(s, code_ptr, (tcg_insn_unit *)value);
     case R_RISCV_CALL:
-        return reloc_call(code_ptr, (tcg_insn_unit *)value);
+        return reloc_call(s, code_ptr, (tcg_insn_unit *)value);
     default:
         tcg_abort();
     }
@@ -559,7 +565,7 @@ static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg rd,
     if (tmp == (int32_t)tmp) {
         tcg_out_opc_upper(s, OPC_AUIPC, rd, 0);
         tcg_out_opc_imm(s, OPC_ADDI, rd, rd, 0);
-        ret = reloc_call(s->code_ptr - 2, (tcg_insn_unit *)val);
+        ret = reloc_call(s, s->code_ptr - 2, (tcg_insn_unit *)val);
         tcg_debug_assert(ret == true);
         return;
     }
@@ -856,14 +862,14 @@ static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
     g_assert_not_reached();
 }
 
-static inline void tcg_out_goto(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = tcg_pcrel_diff(s, target);
     tcg_debug_assert(offset == sextreg(offset, 1, 20) << 1);
     tcg_out_opc_jump(s, OPC_JAL, TCG_REG_ZERO, offset);
 }
 
-static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
+static void tcg_out_call_int(TCGContext *s, const tcg_insn_unit *arg, bool tail)
 {
     TCGReg link = tail ? TCG_REG_ZERO : TCG_REG_RA;
     ptrdiff_t offset = tcg_pcrel_diff(s, arg);
@@ -877,7 +883,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
         /* long jump: -2147483646 to 2147483648 */
         tcg_out_opc_upper(s, OPC_AUIPC, TCG_REG_TMP0, 0);
         tcg_out_opc_imm(s, OPC_JALR, link, TCG_REG_TMP0, 0);
-        ret = reloc_call(s->code_ptr - 2, arg);\
+        ret = reloc_call(s, s->code_ptr - 2, arg);\
         tcg_debug_assert(ret == true);
     } else if (TCG_TARGET_REG_BITS == 64) {
         /* far jump: 64-bit */
@@ -890,7 +896,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     tcg_out_call_int(s, arg, false);
 }
@@ -1024,7 +1030,8 @@ static void add_qemu_ldst_label(TCGContext *s, int is_ld, TCGMemOpIdx oi,
                                 TCGType ext,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                void *raddr, tcg_insn_unit **label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit **label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1054,7 +1061,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     /* resolve label address */
-    if (!patch_reloc(l->label_ptr[0], R_RISCV_BRANCH,
+    if (!patch_reloc(s, l->label_ptr[0], R_RISCV_BRANCH,
                      (intptr_t) s->code_ptr, 0)) {
         return false;
     }
@@ -1089,7 +1096,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     /* resolve label address */
-    if (!patch_reloc(l->label_ptr[0], R_RISCV_BRANCH,
+    if (!patch_reloc(s, l->label_ptr[0], R_RISCV_BRANCH,
                      (intptr_t) s->code_ptr, 0)) {
         return false;
     }
@@ -1276,7 +1283,7 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
 #endif
 }
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg *args, const int *const_args)
diff --git a/tcg/s390/tcg-target.h b/tcg/s390/tcg-target.h
index 07accabbd1..6fe4496e20 100644
--- a/tcg/s390/tcg-target.h
+++ b/tcg/s390/tcg-target.h
@@ -149,13 +149,24 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
     intptr_t disp = addr - (jmp_addr - 2);
     atomic_set((int32_t *)jmp_addr, disp / 2);
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 #ifdef CONFIG_SOFTMMU
diff --git a/tcg/s390/tcg-target.inc.c b/tcg/s390/tcg-target.inc.c
index b07e9ff7d6..d6cb5c05c5 100644
--- a/tcg/s390/tcg-target.inc.c
+++ b/tcg/s390/tcg-target.inc.c
@@ -363,10 +363,10 @@ static void * const qemu_st_helpers[16] = {
 };
 #endif
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 uint64_t s390_facilities;
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     intptr_t pcrel2;
@@ -378,13 +378,13 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
     switch (type) {
     case R_390_PC16DBL:
         if (pcrel2 == (int16_t)pcrel2) {
-            tcg_patch16(code_ptr, pcrel2);
+            tcg_patch16(s, code_ptr, pcrel2);
             return true;
         }
         break;
     case R_390_PC32DBL:
         if (pcrel2 == (int32_t)pcrel2) {
-            tcg_patch32(code_ptr, pcrel2);
+            tcg_patch32(s, code_ptr, pcrel2);
             return true;
         }
         break;
@@ -392,7 +392,7 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         if (value == sextract64(value, 0, 20)) {
             old = *(uint32_t *)code_ptr & 0xf00000ff;
             old |= ((value & 0xfff) << 16) | ((value & 0xff000) >> 4);
-            tcg_patch32(code_ptr, old);
+            tcg_patch32(s, code_ptr, old);
             return true;
         }
         break;
@@ -1306,7 +1306,7 @@ static void tgen_extract(TCGContext *s, TCGReg dest, TCGReg src,
     tcg_out_risbg(s, dest, src, 64 - len, 63, 64 - ofs, 1);
 }
 
-static void tgen_gotoi(TCGContext *s, int cc, tcg_insn_unit *dest)
+static void tgen_gotoi(TCGContext *s, int cc, const tcg_insn_unit *dest)
 {
     ptrdiff_t off = dest - s->code_ptr;
     if (off == (int16_t)off) {
@@ -1419,7 +1419,7 @@ static void tgen_brcond(TCGContext *s, TCGType type, TCGCond c,
     tgen_branch(s, cc, l);
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     ptrdiff_t off = dest - s->code_ptr;
     if (off == (int32_t)off) {
@@ -1597,7 +1597,8 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGReg addr_reg, MemOp opc,
 
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg data, TCGReg addr,
-                                tcg_insn_unit *raddr, tcg_insn_unit *label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1616,7 +1617,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!patch_reloc(lb->label_ptr[0], R_390_PC16DBL,
+    if (!patch_reloc(s, lb->label_ptr[0], R_390_PC16DBL,
                      (intptr_t)s->code_ptr, 2)) {
         return false;
     }
@@ -1641,7 +1642,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!patch_reloc(lb->label_ptr[0], R_390_PC16DBL,
+    if (!patch_reloc(s, lb->label_ptr[0], R_390_PC16DBL,
                      (intptr_t)s->code_ptr, 2)) {
         return false;
     }
@@ -2579,9 +2580,9 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_insn(s, RR, BCR, S390_CC_ALWAYS, TCG_REG_R14);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
-    memset(p, 0x07, count * sizeof(tcg_insn_unit));
+    memset(TCG_CODE_PTR_RW(s, p), 0x07, count * sizeof(tcg_insn_unit));
 }
 
 typedef struct {
diff --git a/tcg/sparc/tcg-target.h b/tcg/sparc/tcg-target.h
index 633841ebf2..d102e13692 100644
--- a/tcg/sparc/tcg-target.h
+++ b/tcg/sparc/tcg-target.h
@@ -176,7 +176,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     }
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #define TCG_TARGET_NEED_POOL_LABELS
 
diff --git a/tcg/sparc/tcg-target.inc.c b/tcg/sparc/tcg-target.inc.c
index 65fddb310d..49adf6cf82 100644
--- a/tcg/sparc/tcg-target.inc.c
+++ b/tcg/sparc/tcg-target.inc.c
@@ -291,14 +291,14 @@ static inline int check_fit_i32(int32_t val, unsigned int bits)
 # define check_fit_ptr  check_fit_i32
 #endif
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     uint32_t insn = *code_ptr;
     intptr_t pcrel;
 
     value += addend;
-    pcrel = tcg_ptr_byte_diff((tcg_insn_unit *)value, code_ptr);
+    pcrel = tcg_ptr_byte_diff((const tcg_insn_unit *)value, code_ptr);
 
     switch (type) {
     case R_SPARC_WDISP16:
@@ -845,7 +845,7 @@ static void tcg_out_addsub2_i64(TCGContext *s, TCGReg rl, TCGReg rh,
     tcg_out_mov(s, TCG_TYPE_I64, rl, tmp);
 }
 
-static void tcg_out_call_nodelay(TCGContext *s, tcg_insn_unit *dest,
+static void tcg_out_call_nodelay(TCGContext *s, const tcg_insn_unit *dest,
                                  bool in_prologue)
 {
     ptrdiff_t disp = tcg_pcrel_diff(s, dest);
@@ -860,7 +860,7 @@ static void tcg_out_call_nodelay(TCGContext *s, tcg_insn_unit *dest,
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_call_nodelay(s, dest, false);
     tcg_out_nop(s);
@@ -873,8 +873,8 @@ static void tcg_out_mb(TCGContext *s, TCGArg a0)
 }
 
 #ifdef CONFIG_SOFTMMU
-static tcg_insn_unit *qemu_ld_trampoline[16];
-static tcg_insn_unit *qemu_st_trampoline[16];
+static const tcg_insn_unit *qemu_ld_trampoline[16];
+static const tcg_insn_unit *qemu_st_trampoline[16];
 
 static void emit_extend(TCGContext *s, TCGReg r, int op)
 {
@@ -1053,11 +1053,11 @@ static void tcg_target_qemu_prologue(TCGContext *s)
 #endif
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
@@ -1168,7 +1168,7 @@ static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,
 #ifdef CONFIG_SOFTMMU
     unsigned memi = get_mmuidx(oi);
     TCGReg addrz, param;
-    tcg_insn_unit *func;
+    const tcg_insn_unit *func;
     tcg_insn_unit *label_ptr;
 
     addrz = tcg_out_tlb_load(s, addr, memi, memop,
@@ -1231,7 +1231,8 @@ static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,
         }
     }
 
-    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));
+    *TCG_CODE_PTR_RW(s, label_ptr) |=
+        INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));
 #else
     if (SPARC64 && TARGET_LONG_BITS == 32) {
         tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);
@@ -1827,7 +1828,7 @@ void tcg_register_jit(void *buf, size_t buf_size)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     intptr_t tb_disp = addr - tc_ptr;
     intptr_t br_disp = addr - jmp_addr;
@@ -1840,6 +1841,9 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
 
     if (!USE_REG_TB) {
         atomic_set((uint32_t *)jmp_addr, deposit32(CALL, 0, 30, br_disp >> 2));
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 4);
         return;
     }
@@ -1864,5 +1868,8 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
     }
 
     atomic_set((uint64_t *)jmp_addr, deposit64(i2, 32, 32, i1));
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 8);
 }
diff --git a/tcg/tcg-ldst.inc.c b/tcg/tcg-ldst.inc.c
index 05f9b3ccd6..eaba08700e 100644
--- a/tcg/tcg-ldst.inc.c
+++ b/tcg/tcg-ldst.inc.c
@@ -28,7 +28,7 @@ typedef struct TCGLabelQemuLdst {
     TCGReg addrhi_reg;      /* reg index for high word of guest virtual addr */
     TCGReg datalo_reg;      /* reg index for low word to be loaded or stored */
     TCGReg datahi_reg;      /* reg index for high word to be loaded or stored */
-    tcg_insn_unit *raddr;   /* gen code addr of the next IR of qemu_ld/st IR */
+    const tcg_insn_unit *raddr; /* gen code addr of the next IR of qemu_ld/st */
     tcg_insn_unit *label_ptr[2]; /* label pointers to be updated */
     QSIMPLEQ_ENTRY(TCGLabelQemuLdst) next;
 } TCGLabelQemuLdst;
diff --git a/tcg/tcg-pool.inc.c b/tcg/tcg-pool.inc.c
index 4eaa84b631..2c23162d74 100644
--- a/tcg/tcg-pool.inc.c
+++ b/tcg/tcg-pool.inc.c
@@ -119,7 +119,7 @@ static inline void new_pool_l8(TCGContext *s, int rtype, tcg_insn_unit *label,
 }
 
 /* To be provided by cpu/tcg-target.inc.c.  */
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count);
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count);
 
 static int tcg_out_pool_finalize(TCGContext *s)
 {
@@ -135,7 +135,7 @@ static int tcg_out_pool_finalize(TCGContext *s)
        again when allocating the next TranslationBlock structure.  */
     a = (void *)ROUND_UP((uintptr_t)s->code_ptr,
                          sizeof(tcg_target_ulong) * p->nlong);
-    tcg_out_nop_fill(s->code_ptr, (tcg_insn_unit *)a - s->code_ptr);
+    tcg_out_nop_fill(s, s->code_ptr, (tcg_insn_unit *)a - s->code_ptr);
     s->data_gen_ptr = a;
 
     for (; p != NULL; p = p->next) {
@@ -144,11 +144,12 @@ static int tcg_out_pool_finalize(TCGContext *s)
             if (unlikely(a > s->code_gen_highwater)) {
                 return -1;
             }
-            memcpy(a, p->data, size);
+            memcpy(TCG_CODE_PTR_RW(s, a), p->data, size);
             a += size;
             l = p;
         }
-        if (!patch_reloc(p->label, p->rtype, (intptr_t)a - size, p->addend)) {
+        if (!patch_reloc(s, p->label, p->rtype,
+                         (intptr_t)a - size, p->addend)) {
             return -2;
         }
     }
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 1362bc6101..ab0e7a4ae6 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -70,7 +70,7 @@
 static void tcg_target_init(TCGContext *s);
 static const TCGTargetOpDef *tcg_target_op_def(TCGOpcode);
 static void tcg_target_qemu_prologue(TCGContext *s);
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend);
 
 /* The CIE and FDE header definitions will be common to all hosts.  */
@@ -148,7 +148,7 @@ static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
                        intptr_t arg2);
 static bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
                         TCGReg base, intptr_t ofs);
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *target);
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *target);
 static int tcg_target_const_match(tcg_target_long val, TCGType type,
                                   const TCGArgConstraint *arg_ct);
 #ifdef TCG_TARGET_NEED_LDST_LABELS
@@ -203,13 +203,15 @@ static TCGRegSet tcg_target_call_clobber_regs;
 #if TCG_TARGET_INSN_UNIT_SIZE == 1
 static __attribute__((unused)) inline void tcg_out8(TCGContext *s, uint8_t v)
 {
-    *s->code_ptr++ = v;
+    *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+    s->code_ptr++;
 }
 
-static __attribute__((unused)) inline void tcg_patch8(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch8(TCGContext *s,
+                                                      tcg_insn_unit *p,
                                                       uint8_t v)
 {
-    *p = v;
+    *TCG_CODE_PTR_RW(s, p) = v;
 }
 #endif
 
@@ -217,21 +219,23 @@ static __attribute__((unused)) inline void tcg_patch8(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out16(TCGContext *s, uint16_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 2) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (2 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch16(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch16(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint16_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 2) {
-        *p = v;
+        *TCG_CODE_PTR_RW(s, p) = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -240,21 +244,23 @@ static __attribute__((unused)) inline void tcg_patch16(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out32(TCGContext *s, uint32_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 4) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (4 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch32(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch32(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint32_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 4) {
         *p = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -263,21 +269,23 @@ static __attribute__((unused)) inline void tcg_patch32(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out64(TCGContext *s, uint64_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 8) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (8 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch64(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch64(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint64_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 8) {
         *p = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -295,7 +303,7 @@ static void tcg_out_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
     QSIMPLEQ_INSERT_TAIL(&l->relocs, r, next);
 }
 
-static void tcg_out_label(TCGContext *s, TCGLabel *l, tcg_insn_unit *ptr)
+static void tcg_out_label(TCGContext *s, TCGLabel *l, const tcg_insn_unit *ptr)
 {
     tcg_debug_assert(!l->has_value);
     l->has_value = 1;
@@ -325,7 +333,7 @@ static bool tcg_resolve_relocs(TCGContext *s)
         uintptr_t value = l->u.value;
 
         QSIMPLEQ_FOREACH(r, &l->relocs, next) {
-            if (!patch_reloc(r->ptr, r->type, value, r->addend)) {
+            if (!patch_reloc(s, r->ptr, r->type, value, r->addend)) {
                 return false;
             }
         }
@@ -1043,7 +1051,7 @@ TranslationBlock *tcg_tb_alloc(TCGContext *s)
     }
     atomic_set(&s->code_gen_ptr, next);
     s->data_gen_ptr = NULL;
-    return tb;
+    return (TranslationBlock *)TCG_CODE_PTR_RW(s, tb);
 }
 
 void tcg_prologue_init(TCGContext *s)
@@ -1080,6 +1088,10 @@ void tcg_prologue_init(TCGContext *s)
 #endif
 
     buf1 = s->code_ptr;
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range((uintptr_t)TCG_CODE_PTR_RW(s, buf0),
+                       (uintptr_t)TCG_CODE_PTR_RW(s, buf1));
+#endif
     flush_icache_range((uintptr_t)buf0, (uintptr_t)buf1);
 
     /* Deduct the prologue from the buffer.  */
@@ -4279,6 +4291,12 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
         return -2;
     }
 
+#if defined(CONFIG_IOS_JIT)
+    /* flush data cache on mirror */
+    flush_dcache_range((uintptr_t)TCG_CODE_PTR_RW(s, s->code_buf),
+                       (uintptr_t)TCG_CODE_PTR_RW(s, s->code_ptr));
+#endif
+
     /* flush instruction cache */
     flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);
 
diff --git a/tcg/tci/tcg-target.h b/tcg/tci/tcg-target.h
index 8b90ab71cb..e6bf09d12c 100644
--- a/tcg/tci/tcg-target.h
+++ b/tcg/tci/tcg-target.h
@@ -195,6 +195,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* We could notice __i386__ or __s390x__ and reduce the barriers depending
    on the host.  But if you want performance, you use the normal backend.
    We prefer consistency across hosts on this.  */
@@ -203,11 +210,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
     atomic_set((int32_t *)jmp_addr, addr - (jmp_addr + 4));
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 #endif /* TCG_TARGET_H */
diff --git a/tcg/tci/tcg-target.inc.c b/tcg/tci/tcg-target.inc.c
index 992d50cb1e..baacafa983 100644
--- a/tcg/tci/tcg-target.inc.c
+++ b/tcg/tci/tcg-target.inc.c
@@ -369,7 +369,7 @@ static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
 };
 #endif
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     /* tcg_out_reloc always uses the same type, addend. */
@@ -377,9 +377,9 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
     tcg_debug_assert(addend == 0);
     tcg_debug_assert(value != 0);
     if (TCG_TARGET_REG_BITS == 32) {
-        tcg_patch32(code_ptr, value);
+        tcg_patch32(s, code_ptr, value);
     } else {
-        tcg_patch64(code_ptr, value);
+        tcg_patch64(s, code_ptr, value);
     }
     return true;
 }
@@ -546,7 +546,7 @@ static void tcg_out_movi(TCGContext *s, TCGType type,
     old_code_ptr[1] = s->code_ptr - old_code_ptr;
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     uint8_t *old_code_ptr = s->code_ptr;
     tcg_out_op_t(s, INDEX_op_call);
-- 
2.24.3 (Apple Git-128)

From fc9a7b1fa7104ff5d5a047de892c2d39690af90f Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Tue, 31 Mar 2020 16:20:24 -0700
Subject: [PATCH 5/7] slirp: update for iOS resolv fix

We cannot access /etc/resolv.conf on iOS so libslirp is modified to use
libresolv instead. Since we link to it statically we need to add the
LDFLAGS to qemu.
---
 .gitmodules | 2 +-
 configure   | 2 +-
 slirp       | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/.gitmodules b/.gitmodules
index 4d140cda28..f8fc8f416a 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -51,7 +51,7 @@
 	url = https://git.qemu.org/git/edk2.git
 [submodule "slirp"]
 	path = slirp
-	url = https://git.qemu.org/git/libslirp.git
+	url = https://github.com/utmapp/libslirp.git
 [submodule "roms/opensbi"]
 	path = roms/opensbi
 	url = 	https://git.qemu.org/git/opensbi.git
diff --git a/configure b/configure
index 0ab4633fbd..09faa69a54 100755
--- a/configure
+++ b/configure
@@ -918,7 +918,7 @@ iOS)
   host_device_support="no"
   audio_drv_list=""
   audio_possible_drivers=""
-  QEMU_LDFLAGS="-framework CoreFoundation $QEMU_LDFLAGS"
+  QEMU_LDFLAGS="-framework CoreFoundation -lresolv $QEMU_LDFLAGS"
   # Disable attempts to use ObjectiveC features in os/object.h since they
   # won't work when we're compiling with gcc as a C compiler.
   QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
-- 
2.24.3 (Apple Git-128)

From 71a38e02dd85a22e73355cdc2047ba34fde05064 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 29 Jul 2020 14:14:47 -0700
Subject: [PATCH 6/7] tcg: mirror mapping RWX pages for iOS optional

This allows jailbroken devices with entitlements to switch the option off.
---
 accel/tcg/tcg-all.c       | 44 ++++++++++++++++++++++++++++++-
 accel/tcg/translate-all.c | 54 +++++++++++++++++++++++++--------------
 bsd-user/main.c           |  2 +-
 include/sysemu/tcg.h      |  2 +-
 linux-user/main.c         |  2 +-
 qemu-options.hx           | 12 +++++++++
 6 files changed, 93 insertions(+), 23 deletions(-)

diff --git a/accel/tcg/tcg-all.c b/accel/tcg/tcg-all.c
index eace2c113b..83d8fe43e0 100644
--- a/accel/tcg/tcg-all.c
+++ b/accel/tcg/tcg-all.c
@@ -41,6 +41,7 @@ typedef struct TCGState {
 
     bool mttcg_enabled;
     unsigned long tb_size;
+    bool mirror_rwx;
 } TCGState;
 
 #define TYPE_TCG_ACCEL ACCEL_CLASS_NAME("tcg")
@@ -115,18 +116,36 @@ static bool default_mttcg_enabled(void)
     }
 }
 
+static bool default_mirror_rwx(void)
+{
+#ifdef CONFIG_IOS_JIT // only applicable for iOS
+    void *test = mmap(NULL, qemu_real_host_page_size,
+                      PROT_WRITE | PROT_READ | PROT_EXEC,
+                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);
+    if (test == MAP_FAILED) {
+        return true;
+    } else {
+        munmap(test, qemu_real_host_page_size);
+        return false;
+    }
+#else
+    return false;
+#endif
+}
+
 static void tcg_accel_instance_init(Object *obj)
 {
     TCGState *s = TCG_STATE(obj);
 
     s->mttcg_enabled = default_mttcg_enabled();
+    s->mirror_rwx = default_mirror_rwx();
 }
 
 static int tcg_init(MachineState *ms)
 {
     TCGState *s = TCG_STATE(current_accel());
 
-    tcg_exec_init(s->tb_size * 1024 * 1024);
+    tcg_exec_init(s->tb_size * 1024 * 1024, s->mirror_rwx);
     cpu_interrupt_handler = tcg_handle_interrupt;
     mttcg_enabled = s->mttcg_enabled;
     return 0;
@@ -191,6 +210,22 @@ static void tcg_set_tb_size(Object *obj, Visitor *v,
     s->tb_size = value;
 }
 
+#ifdef CONFIG_IOS_JIT
+static bool tcg_get_mirror_rwx(Object *obj, Error **errp)
+{
+    TCGState *s = TCG_STATE(obj);
+
+    return s->mirror_rwx;
+}
+
+static void tcg_set_mirror_rwx(Object *obj, bool value, Error **errp)
+{
+    TCGState *s = TCG_STATE(obj);
+
+    s->mirror_rwx = value;
+}
+#endif
+
 static void tcg_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -208,6 +243,13 @@ static void tcg_accel_class_init(ObjectClass *oc, void *data)
     object_class_property_set_description(oc, "tb-size",
         "TCG translation block cache size");
 
+#ifdef CONFIG_IOS_JIT
+    object_class_property_add_bool(oc, "mirror-rwx",
+        tcg_get_mirror_rwx, tcg_set_mirror_rwx);
+    object_class_property_set_description(oc, "mirror-rwx",
+        "mirror map executable pages for TCG on iOS");
+#endif
+
 }
 
 static const TypeInfo tcg_accel_type = {
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 039c66698e..3cf6017e2b 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -1041,12 +1041,15 @@ static inline void *split_cross_256mb(void *buf1, size_t size1)
 static uint8_t static_code_gen_buffer[DEFAULT_CODE_GEN_BUFFER_SIZE]
     __attribute__((aligned(CODE_GEN_ALIGN)));
 
-static inline void *alloc_code_gen_buffer(void)
+static inline void *alloc_code_gen_buffer(bool no_rwx_pages)
 {
     void *buf = static_code_gen_buffer;
     void *end = static_code_gen_buffer + sizeof(static_code_gen_buffer);
     size_t size;
 
+    /* not applicable */
+    assert(!no_rwx_pages);
+
     /* page-align the beginning and end of the buffer */
     buf = QEMU_ALIGN_PTR_UP(buf, qemu_real_host_page_size);
     end = QEMU_ALIGN_PTR_DOWN(end, qemu_real_host_page_size);
@@ -1075,24 +1078,32 @@ static inline void *alloc_code_gen_buffer(void)
     return buf;
 }
 #elif defined(_WIN32)
-static inline void *alloc_code_gen_buffer(void)
+static inline void *alloc_code_gen_buffer(bool no_rwx_pages)
 {
     size_t size = tcg_ctx->code_gen_buffer_size;
+    assert(!no_rwx_pages); // not applicable
     return VirtualAlloc(NULL, size, MEM_RESERVE | MEM_COMMIT,
                         PAGE_EXECUTE_READWRITE);
 }
 #else
-static inline void *alloc_code_gen_buffer(void)
+static inline void *alloc_code_gen_buffer(bool no_rwx_pages)
 {
-#if defined(CONFIG_IOS_JIT)
     int prot = PROT_READ | PROT_EXEC;
-#else
-    int prot = PROT_WRITE | PROT_READ | PROT_EXEC;
-#endif
     int flags = MAP_PRIVATE | MAP_ANONYMOUS;
     size_t size = tcg_ctx->code_gen_buffer_size;
     void *buf;
 
+#if defined(CONFIG_DARWIN) // both iOS and macOS (Apple Silicon) applicable
+    if (!no_rwx_pages) {
+        prot |= PROT_WRITE;
+        flags |= MAP_JIT;
+    }
+#else
+    /* not applicable */
+    assert(!no_rwx_pages);
+    prot |= PROT_WRITE;
+#endif
+
     buf = mmap(NULL, size, prot, flags, -1, 0);
     if (buf == MAP_FAILED) {
         return NULL;
@@ -1172,10 +1183,10 @@ static inline void *alloc_jit_rw_mirror(void *base, size_t size)
 }
 #endif /* CONFIG_IOS_JIT */
 
-static inline void code_gen_alloc(size_t tb_size)
+static inline void code_gen_alloc(size_t tb_size, bool mirror_rwx)
 {
     tcg_ctx->code_gen_buffer_size = size_code_gen_buffer(tb_size);
-    tcg_ctx->code_gen_buffer = alloc_code_gen_buffer();
+    tcg_ctx->code_gen_buffer = alloc_code_gen_buffer(mirror_rwx);
     if (tcg_ctx->code_gen_buffer == NULL) {
         fprintf(stderr, "Could not allocate dynamic translator buffer\n");
         exit(1);
@@ -1183,13 +1194,18 @@ static inline void code_gen_alloc(size_t tb_size)
 #if defined(CONFIG_IOS_JIT)
     void *mirror;
 
-    /* For iOS JIT we need a mirror mapping for code execution */
-    mirror = alloc_jit_rw_mirror(tcg_ctx->code_gen_buffer,
-                                 tcg_ctx->code_gen_buffer_size
-                                );
-    if (mirror == NULL) {
-        fprintf(stderr, "Could not remap code buffer mirror\n");
-        exit(1);
+    if (mirror_rwx) {
+        /* For iOS JIT we need a mirror mapping for code execution */
+        mirror = alloc_jit_rw_mirror(tcg_ctx->code_gen_buffer,
+                                     tcg_ctx->code_gen_buffer_size
+                                    );
+        if (mirror == NULL) {
+            fprintf(stderr, "Could not remap code buffer mirror\n");
+            exit(1);
+        }
+    } else {
+        /* If we have JIT entitlements */
+        mirror = tcg_ctx->code_gen_buffer;
     }
     tcg_ctx->code_rw_mirror_diff = mirror - tcg_ctx->code_gen_buffer;
 #endif /* CONFIG_IOS_JIT */
@@ -1218,14 +1234,14 @@ static void tb_htable_init(void)
 
 /* Must be called before using the QEMU cpus. 'tb_size' is the size
    (in bytes) allocated to the translation buffer. Zero means default
-   size. */
-void tcg_exec_init(unsigned long tb_size)
+   size. mirror_rwx only applicable on iOS. */
+void tcg_exec_init(unsigned long tb_size, bool mirror_rwx)
 {
     tcg_allowed = true;
     cpu_gen_init();
     page_init();
     tb_htable_init();
-    code_gen_alloc(tb_size);
+    code_gen_alloc(tb_size, mirror_rwx);
 #if defined(CONFIG_SOFTMMU)
     /* There's no guest base to take into account, so go ahead and
        initialize the prologue now.  */
diff --git a/bsd-user/main.c b/bsd-user/main.c
index ac40d79bfa..ffd4888a26 100644
--- a/bsd-user/main.c
+++ b/bsd-user/main.c
@@ -910,7 +910,7 @@ int main(int argc, char **argv)
     }
 
     /* init tcg before creating CPUs and to get qemu_host_page_size */
-    tcg_exec_init(0);
+    tcg_exec_init(0, false);
 
     cpu_type = parse_cpu_option(cpu_model);
     cpu = cpu_create(cpu_type);
diff --git a/include/sysemu/tcg.h b/include/sysemu/tcg.h
index d9d3ca8559..569f90b11d 100644
--- a/include/sysemu/tcg.h
+++ b/include/sysemu/tcg.h
@@ -8,7 +8,7 @@
 #ifndef SYSEMU_TCG_H
 #define SYSEMU_TCG_H
 
-void tcg_exec_init(unsigned long tb_size);
+void tcg_exec_init(unsigned long tb_size, bool mirror_rwx);
 #ifdef CONFIG_TCG
 extern bool tcg_allowed;
 #define tcg_enabled() (tcg_allowed)
diff --git a/linux-user/main.c b/linux-user/main.c
index 75c9785157..3856b2611d 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -705,7 +705,7 @@ int main(int argc, char **argv, char **envp)
     cpu_type = parse_cpu_option(cpu_model);
 
     /* init tcg before creating CPUs and to get qemu_host_page_size */
-    tcg_exec_init(0);
+    tcg_exec_init(0, false);
 
     cpu = cpu_create(cpu_type);
     env = cpu->env_ptr;
diff --git a/qemu-options.hx b/qemu-options.hx
index 708583b4ce..a5b56f9963 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -123,6 +123,9 @@ DEF("accel", HAS_ARG, QEMU_OPTION_accel,
     "                igd-passthru=on|off (enable Xen integrated Intel graphics passthrough, default=off)\n"
     "                kernel-irqchip=on|off|split controls accelerated irqchip support (default=on)\n"
     "                kvm-shadow-mem=size of KVM shadow MMU in bytes\n"
+#ifdef CONFIG_IOS_JIT
+    "                mirror-rwx=on|off (mirror map executable pages for TCG on iOS)\n"
+#endif
     "                tb-size=n (TCG translation block cache size)\n"
     "                thread=single|multi (enable multi-threaded TCG)\n", QEMU_ARCH_ALL)
 SRST
@@ -148,6 +151,15 @@ SRST
     ``kvm-shadow-mem=size``
         Defines the size of the KVM shadow MMU.
 
+#ifdef CONFIG_IOS_JIT
+
+    ``mirror-rwx=on|off``
+        Only applicable to TCG running on iOS hosts. When enabled, TB code
+        is written to a mirror mapped address separate from the address that is
+        executed. By default, this is enabled if running on Darwin and mmap
+        fails to allocate PROT_WRITE | PROT_READ | PROT_EXEC.
+#endif
+
     ``tb-size=n``
         Controls the size (in MiB) of the TCG translation block cache.
 
-- 
2.24.3 (Apple Git-128)

From 3665d6d7e26ca01e02ca6b9a5ae361c9bb24e123 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 29 Jul 2020 14:15:54 -0700
Subject: [PATCH 7/7] tcg: support JIT on Apple Silicon

https://developer.apple.com/documentation/apple_silicon/porting_just-in-time_compilers_to_apple_silicon
---
 accel/tcg/cpu-exec.c | 22 ++++++++++++++++++++++
 configure            | 19 +++++++++++++++++++
 2 files changed, 41 insertions(+)

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 39173ffed6..5295ec7d4d 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -137,6 +137,26 @@ static void init_delay_params(SyncClocks *sc, const CPUState *cpu)
 }
 #endif /* CONFIG USER ONLY */
 
+#if defined(HAVE_PTHREAD_JIT_PROTECT)
+static void tb_pre_exec(void)
+{
+    if (__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        pthread_jit_write_protect_np(true);
+        // sys_icache_invalidate should already be called!
+    }
+}
+
+static void tb_post_exec(void)
+{
+    if (__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        pthread_jit_write_protect_np(false);
+    }
+}
+#else // not needed on non-Darwin platforms
+static void tb_pre_exec(void) {}
+static void tb_post_exec(void) {}
+#endif
+
 /* Execute a TB, and fix up the CPU state afterwards if necessary */
 static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
 {
@@ -169,7 +189,9 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
     }
 #endif /* DEBUG_DISAS */
 
+    tb_pre_exec();
     ret = tcg_qemu_tb_exec(env, tb_ptr);
+    tb_post_exec();
     cpu->can_do_io = 1;
     last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
     tb_exit = ret & TB_EXIT_MASK;
diff --git a/configure b/configure
index 09faa69a54..44d1f3644d 100755
--- a/configure
+++ b/configure
@@ -6588,6 +6588,21 @@ EOF
     fi
 fi
 
+##########################################
+# check for Apple Silicon JIT function
+
+if [ "$darwin" = "yes" ] ; then
+  cat > $TMPC << EOF
+#include <pthread.h>
+int main() { pthread_jit_write_protect_np(0); return 0; }
+EOF
+  if ! compile_prog ""; then
+    have_pthread_jit_protect='no'
+  else
+    have_pthread_jit_protect='yes'
+  fi
+fi
+
 
 ##########################################
 # End of CC checks
@@ -8021,6 +8036,10 @@ if test "$secret_keyring" = "yes" ; then
   fi
 fi
 
+if test "$have_pthread_jit_protect" = "yes" ; then
+  echo "HAVE_PTHREAD_JIT_PROTECT=y" >> $config_host_mak
+fi
+
 if test "$tcg_interpreter" = "yes"; then
   QEMU_INCLUDES="-iquote \$(SRC_PATH)/tcg/tci $QEMU_INCLUDES"
 elif test "$ARCH" = "sparc64" ; then
-- 
2.24.3 (Apple Git-128)

diff -Naur a/libucontext/LICENSE b/libucontext/LICENSE
--- a/libucontext/LICENSE	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/LICENSE	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,9 @@
+Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+This software is provided 'as is' and without any warranty, express or
+implied.  In no event shall the authors be liable for any damages arising
+from the use of this software.
diff -Naur a/libucontext/Makefile b/libucontext/Makefile
--- a/libucontext/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/Makefile	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+ARCH := $(shell uname -m)
+
+ROOT_DIR := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+BUILD_DIR ?= .
+
+LIBUCONTEXT = $(BUILD_DIR)/libucontext.a
+
+all: $(LIBUCONTEXT)
+
+CSRCS := $(wildcard arch/${ARCH}/*.c)
+SSRCS := $(wildcard arch/${ARCH}/*.S)
+OBJS := $(CSRCS:%.c=$(BUILD_DIR)/%.o) $(SSRCS:%.S=$(BUILD_DIR)/%.o)
+DEPS := $(OBJS:%.o=%.d)
+
+INC_DIRS := include $(BUILD_DIR)/arch/${ARCH}
+INC_FLAGS := $(addprefix -I,$(INC_DIRS))
+
+override CFLAGS +=					\
+	-DG_LOG_DOMAIN='"ucontext"'			\
+	$(INC_FLAGS)					\
+	-MMD -MP
+
+$(LIBUCONTEXT): $(OBJS)
+
+.PHONY: clean
+
+clean:
+	rm -r $(OBJS) $(DEPS) $(LIBUCONTEXT)
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.c
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.S
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+%.a:
+	$(call quiet-command,rm -f $@ && $(AR) rcs $@ $^,"AR","$@")
+
+MKDIR_P ?= mkdir -p
+quiet-command-run = $(if $(V),,$(if $2,printf "  %-7s %s\n" $2 $3 && ))$1
+quiet-@ = $(if $(V),,@)
+quiet-command = $(quiet-@)$(call quiet-command-run,$1,$2,$3)
+
+print-%:
+	@echo '$*=$($*)'
+
+.SUFFIXES:
+
+-include $(DEPS)
diff -Naur a/libucontext/README.md b/libucontext/README.md
--- a/libucontext/README.md	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/README.md	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,43 @@
+# `libucontext`
+
+`libucontext` is a library which provides the `ucontext.h` C API.  Unlike other implementations,
+it faithfully follows the kernel process ABI when doing context swaps.
+
+Notably, when combined with `gcompat`, it provides a fully compatible implementation of the ucontext
+functions that are ABI compatible with glibc.
+
+
+## supported architectures
+
+Adding support for new architectures is easy, but you need to know assembly language to do it.
+
+Right now these archs are supported and should work on bare metal:
+
+ * x86
+ * x86_64
+ * armv6+ (`arm`)
+ * aarch64
+ * s390x
+
+These archs require kernel assistance and use a syscall (the only assembly is the trampoline):
+
+ * ppc
+ * ppc64 (ELFv2 ABI spec only, ELFv1 not supported)
+
+
+## building
+
+`libucontext` uses a simple makefile build system.  You should define `ARCH=` at build time, otherwise
+the build system will attempt to guess using `uname -m`.
+
+```
+$ make ARCH=x86_64
+$ make ARCH=x86_64 check
+$ make ARCH=x86_64 DESTDIR=out install
+```
+
+
+## support
+
+`libucontext` is offered as part of the `gcompat` project.  Accordingly, please address all questions
+and bug reports to gcompat@lists.adelielinux.org.
diff -Naur a/libucontext/arch/aarch64/defs.h b/libucontext/arch/aarch64/defs.h
--- a/libucontext/arch/aarch64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+#ifndef __ARCH_AARCH64_DEFS_H
+#define __ARCH_AARCH64_DEFS_H
+
+#define REGSZ   8
+#ifdef CUSTOM_IMPL
+#define R0_OFFSET 56
+#define SP_OFFSET 304
+#define PC_OFFSET 312
+#define PSTATE_OFFSET 320
+#else
+#define R0_OFFSET 184
+#define SP_OFFSET 432
+#define PC_OFFSET 440
+#define PSTATE_OFFSET 448
+#endif
+
+#ifndef FPSIMD_MAGIC
+# define FPSIMD_MAGIC	0x46508001
+#endif
+
+#ifndef ESR_MAGIC
+# define ESR_MAGIC	0x45535201
+#endif
+
+#endif
diff -Naur a/libucontext/arch/aarch64/getcontext.S b/libucontext/arch/aarch64/getcontext.S
--- a/libucontext/arch/aarch64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x0, x1,   [x0, #R0_OFFSET + (0 * REGSZ)]
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* TODO: SIMD / FPRs */
+
+	mov	x0, #0
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/makecontext.c b/libucontext/arch/aarch64/makecontext.c
--- a/libucontext/arch/aarch64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#define UCONTEXT_T libucontext_ucontext_t
+#else
+#define UCONTEXT_T ucontext_t
+#define _GNU_SOURCE
+#include <signal.h>
+#include <string.h>
+#include <stdio.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= argc < 8 ? 0 : argc - 8;
+	sp = (unsigned long *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.sp = (uintptr_t) sp;
+	ucp->uc_mcontext.pc = (uintptr_t) func;
+	ucp->uc_mcontext.regs[19] = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.regs[30] = (uintptr_t) &_start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.regs[0]);
+
+	for (i = 0; (i < argc && i < 8); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/aarch64/setcontext.S b/libucontext/arch/aarch64/setcontext.S
--- a/libucontext/arch/aarch64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* restore GPRs */
+	ldp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	ldp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	ldp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	ldp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	ldp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	ldp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	ldr	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current stack pointer */
+	ldr	x2, [x0, #SP_OFFSET]
+	mov	sp, x2
+
+	/* TODO: SIMD / FPRs */
+
+	/* save current program counter in link register */
+	ldr	x16, [x0, #PC_OFFSET]
+
+	/* restore args */
+	ldp	x2, x3, [x0, #R0_OFFSET + (2 * REGSZ)]
+	ldp	x4, x5, [x0, #R0_OFFSET + (4 * REGSZ)]
+	ldp	x6, x7, [x0, #R0_OFFSET + (6 * REGSZ)]
+	ldp	x0, x1, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* jump to new PC */
+	br	x16
+.align 2
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mov	x0, x19
+	cbnz	x0, _libucontext_setcontext
+
+	/* something went wrong, exit */
+	b	_exit
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/swapcontext.S b/libucontext/arch/aarch64/swapcontext.S
--- a/libucontext/arch/aarch64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* context to swap to is in x1 so... we move to x0 and call setcontext */
+	/* store our link register in x28 */
+	mov	x28, x30
+
+	/* move x1 to x0 and call setcontext */
+	mov	x0, x1
+	bl	_libucontext_setcontext
+
+	/* hmm, we came back here try to return */
+	mov	x30, x28
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/arch/arm/getcontext.S b/libucontext/arch/arm/getcontext.S
--- a/libucontext/arch/arm/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __getcontext;
+__getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r1, r0, #48
+	stmia	r1, {r4-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* return 0 */
+	mov	r0, #0
+	mov	pc, lr
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/arm/makecontext.c b/libucontext/arch/arm/makecontext.c
--- a/libucontext/arch/arm/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdio.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp = (unsigned long *) (((uintptr_t) sp & -16L) - 8);
+
+	if (argc > 4)
+		sp -= (argc - 4);
+
+	ucp->uc_mcontext.arm_sp = (uintptr_t) sp;
+	ucp->uc_mcontext.arm_pc = (uintptr_t) func;
+	ucp->uc_mcontext.arm_r4 = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.arm_lr = (uintptr_t) &__start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.arm_r0);
+
+	for (i = 0; (i < argc && i < 4); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+
+/*
+	printf("R4 offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_r4));
+	printf("SP offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_sp));
+	printf("LR offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_lr));
+	printf("PC offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_pc));
+ */
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/arm/setcontext.S b/libucontext/arch/arm/setcontext.S
--- a/libucontext/arch/arm/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __setcontext;
+__setcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r14, r0, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+
+	/* load link register and jump to new context */
+	ldmia	r14, {r14, pc}
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/arm/startcontext.S b/libucontext/arch/arm/startcontext.S
--- a/libucontext/arch/arm/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.fnstart
+.cantunwind
+	nop
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movs	r0, r4
+	bne	__setcontext@plt
+
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	b	exit@plt
diff -Naur a/libucontext/arch/arm/swapcontext.S b/libucontext/arch/arm/swapcontext.S
--- a/libucontext/arch/arm/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __swapcontext;
+__swapcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r2, r0, #32
+	stmia	r2, {r0-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* load new registers from the second ucontext structure */
+	add	r14, r1, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+	ldmia	r14, {r14, pc}
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/ppc/defs.h b/libucontext/arch/ppc/defs.h
--- a/libucontext/arch/ppc/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* lnk register is actually r32 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc/getcontext.c b/libucontext/arch/ppc/getcontext.c
--- a/libucontext/arch/ppc/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc/makecontext.c b/libucontext/arch/ppc/makecontext.c
--- a/libucontext/arch/ppc/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_NIP]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_LNK]  = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gregs[REG_R31]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[REG_SP]   = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gregs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc/setcontext.c b/libucontext/arch/ppc/setcontext.c
--- a/libucontext/arch/ppc/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc/startcontext.S b/libucontext/arch/ppc/startcontext.S
--- a/libucontext/arch/ppc/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mr.	3,31
+
+	/* if we have no linked context, lets get out of here */
+	beq	no_linked_context
+
+	/* jump to setcontext */
+	bl	__setcontext@local
+
+no_linked_context:
+	b	exit@GOT
diff -Naur a/libucontext/arch/ppc/swapcontext.c b/libucontext/arch/ppc/swapcontext.c
--- a/libucontext/arch/ppc/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/ppc64/defs.h b/libucontext/arch/ppc64/defs.h
--- a/libucontext/arch/ppc64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* entry register is actually %r12 */
+#define REG_ENTRY	REG_R12
+
+/* lnk register is actually %r36 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc64/getcontext.c b/libucontext/arch/ppc64/getcontext.c
--- a/libucontext/arch/ppc64/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc64/makecontext.c b/libucontext/arch/ppc64/makecontext.c
--- a/libucontext/arch/ppc64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gp_regs[REG_NIP]   = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_LNK]   = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gp_regs[REG_SP]    = (uintptr_t) sp;
+	ucp->uc_mcontext.gp_regs[REG_ENTRY] = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_R31]   = (uintptr_t) ucp->uc_link;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gp_regs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc64/setcontext.c b/libucontext/arch/ppc64/setcontext.c
--- a/libucontext/arch/ppc64/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc64/startcontext.S b/libucontext/arch/ppc64/startcontext.S
--- a/libucontext/arch/ppc64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.hidden __start_context;
+__start_context:
+	cmpdi	31,0			/* test if ucontext link pointer is null */
+	beq	no_linked_context	/* if it is, exit */
+
+	/* now, call SYS_swapcontext */
+	mr      4,31			/* ucp is in r31 */
+	li      3,0			/* don't care about restoring, set oucp to NULL */
+	li      5,1696			/* sizeof(ucontext_t) */
+	li      0,249			/* SYS_swapcontext */
+	sc
+
+	/* we should not wind back up here, if we do, exit with -1 */
+	li	3,-1
+
+no_linked_context:
+	b	exit@GOT
+	nop
diff -Naur a/libucontext/arch/ppc64/swapcontext.c b/libucontext/arch/ppc64/swapcontext.c
--- a/libucontext/arch/ppc64/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/s390x/defs.h b/libucontext/arch/s390x/defs.h
--- a/libucontext/arch/s390x/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,8 @@
+#ifndef __ARCH_S390X_DEFS_H
+#define __ARCH_S390X_DEFS_H
+
+#define OFFSET_GREGS	(56)
+#define OFFSET_AREGS	(184)
+#define OFFSET_FPREGS	(248)
+
+#endif
diff -Naur a/libucontext/arch/s390x/getcontext.S b/libucontext/arch/s390x/getcontext.S
--- a/libucontext/arch/s390x/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __getcontext;
+__getcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+	la	%r2, 0				/* we will return 0 */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to where we came from */
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/s390x/makecontext.c b/libucontext/arch/s390x/makecontext.c
--- a/libucontext/arch/s390x/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+extern int __setcontext(const ucontext_t *ucp);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int stack_args;
+
+	stack_args = argc > 5 ? argc - 5 : 0;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= stack_args;		// maybe +1
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gregs[7]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[8]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[9]  = (uintptr_t) &__setcontext;
+	ucp->uc_mcontext.gregs[14] = (uintptr_t) &__start_context;
+
+	argp = sp;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+			ucp->uc_mcontext.gregs[i + 2] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+
+	/* make room for backchain / register save area */
+	sp -= 20;
+	*sp = 0;
+
+	/* set up %r15 as sp */
+	ucp->uc_mcontext.gregs[15] = (uintptr_t) sp;
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/s390x/setcontext.S b/libucontext/arch/s390x/setcontext.S
--- a/libucontext/arch/s390x/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __setcontext;
+__setcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+
+	lam	%a2, %a15, OFFSET_AREGS+8(%r1)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/s390x/startcontext.S b/libucontext/arch/s390x/startcontext.S
--- a/libucontext/arch/s390x/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __start_context;
+__start_context:
+	basr	%r14, %r7			/* run function pointer (%r7) and return here */
+	ltgr	%r8, %r8			/* check to see if uc_link (%r8) is null */
+
+	jz	no_linked_context		/* if we have no linked context, prepare to exit */
+
+	lgr	%r2, %r8			/* copy the uc_link structure address to %r2 */
+	br	%r9				/* call setcontext */
+
+no_linked_context:
+	la	%r2, 0				/* return 0 */
+	brasl	%r14, exit@plt			/* call exit */
+
+	j	.+2				/* crash if exit returns */
diff -Naur a/libucontext/arch/s390x/swapcontext.S b/libucontext/arch/s390x/swapcontext.S
--- a/libucontext/arch/s390x/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __swapcontext;
+__swapcontext:
+	lgr	%r1, %r2			/* use %r1 to save current context to */
+	lgr	%r0, %r3			/* use %r0 for source context */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	lgr	%r2, %r0			/* swap %r0 to %r2 (XXX: figure out why it hates loading from %r0) */
+	lam	%a2, %a15, OFFSET_AREGS+8(%r2)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r2)	/* load general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86/defs.h b/libucontext/arch/x86/defs.h
--- a/libucontext/arch/x86/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,18 @@
+#ifndef __ARCH_X86_DEFS_H
+#define __ARCH_X86_DEFS_H
+
+#define OFFSET_REG_GS	20
+#define OFFSET_REG_FS	24
+#define OFFSET_REG_ES	28
+#define OFFSET_REG_DS	32
+#define OFFSET_REG_EDI	36
+#define OFFSET_REG_ESI	40
+#define OFFSET_REG_EBP	44
+#define OFFSET_REG_ESP	48
+#define OFFSET_REG_EBX	52
+#define OFFSET_REG_EDX	56
+#define OFFSET_REG_ECX	60
+#define OFFSET_REG_EAX	64
+#define OFFSET_REG_EIP	76
+
+#endif
diff -Naur a/libucontext/arch/x86/getcontext.S b/libucontext/arch/x86/getcontext.S
--- a/libucontext/arch/x86/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __getcontext;
+__getcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/x86/makecontext.c b/libucontext/arch/x86/makecontext.c
--- a/libucontext/arch/x86/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_EIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_EBX] = (uintptr_t) argc;
+	ucp->uc_mcontext.gregs[REG_ESP] = (uintptr_t) sp;
+
+	argp = sp;
+	*argp++ = (uintptr_t) &__start_context;
+	*argp++ = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		*argp++ = va_arg (va, greg_t);
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/x86/setcontext.S b/libucontext/arch/x86/setcontext.S
--- a/libucontext/arch/x86/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __setcontext;
+__setcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/x86/startcontext.S b/libucontext/arch/x86/startcontext.S
--- a/libucontext/arch/x86/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	leal	(%esp,%ebx,4), %esp
+	cmpl	$0, (%esp)
+
+	/* restore global offset table, exit@plt and __setcontext@plt need this */
+	call	__i686.get_pc_thunk.bx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	__setcontext@plt
+	movl	%eax, (%esp)
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	exit@plt
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
+
+
+__i686.get_pc_thunk.bx:
+	mov	(%esp), %ebx
+	ret
diff -Naur a/libucontext/arch/x86/swapcontext.S b/libucontext/arch/x86/swapcontext.S
--- a/libucontext/arch/x86/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __swapcontext;
+__swapcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* load address of the ucontext structure */
+	movl	8(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86_64/defs.h b/libucontext/arch/x86_64/defs.h
--- a/libucontext/arch/x86_64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/defs.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,55 @@
+#ifndef __ARCH_X86_64_DEFS_H
+#define __ARCH_X86_64_DEFS_H
+
+/* Number of each register in the `gregset_t' array.  */
+enum
+{
+  REG_R8 = 0,
+# define REG_R8		REG_R8
+  REG_R9,
+# define REG_R9		REG_R9
+  REG_R10,
+# define REG_R10	REG_R10
+  REG_R11,
+# define REG_R11	REG_R11
+  REG_R12,
+# define REG_R12	REG_R12
+  REG_R13,
+# define REG_R13	REG_R13
+  REG_R14,
+# define REG_R14	REG_R14
+  REG_R15,
+# define REG_R15	REG_R15
+  REG_RDI,
+# define REG_RDI	REG_RDI
+  REG_RSI,
+# define REG_RSI	REG_RSI
+  REG_RBP,
+# define REG_RBP	REG_RBP
+  REG_RBX,
+# define REG_RBX	REG_RBX
+  REG_RDX,
+# define REG_RDX	REG_RDX
+  REG_RAX,
+# define REG_RAX	REG_RAX
+  REG_RCX,
+# define REG_RCX	REG_RCX
+  REG_RSP,
+# define REG_RSP	REG_RSP
+  REG_RIP,
+# define REG_RIP	REG_RIP
+  REG_EFL,
+# define REG_EFL	REG_EFL
+  REG_CSGSFS,		/* Actually short cs, gs, fs, __pad0.  */
+# define REG_CSGSFS	REG_CSGSFS
+  REG_ERR,
+# define REG_ERR	REG_ERR
+  REG_TRAPNO,
+# define REG_TRAPNO	REG_TRAPNO
+  REG_OLDMASK,
+# define REG_OLDMASK	REG_OLDMASK
+  REG_CR2
+# define REG_CR2	REG_CR2
+};
+
+#endif
diff -Naur a/libucontext/arch/x86_64/getcontext.S b/libucontext/arch/x86_64/getcontext.S
--- a/libucontext/arch/x86_64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/makecontext.c b/libucontext/arch/x86_64/makecontext.c
--- a/libucontext/arch/x86_64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/makecontext.c	2020-01-31 20:14:38.000000000 -0800
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <stddef.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#include "defs.h"
+#define UCONTEXT_T libucontext_ucontext_t
+#define GREG_T libucontext_greg_t
+#else
+#define UCONTEXT_T ucontext_t
+#define GREG_T greg_t
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	GREG_T *sp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (GREG_T *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (GREG_T *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[uc_link];
+	ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &_start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+			ucp->uc_mcontext.gregs[REG_RDI] = va_arg (va, GREG_T);
+			break;
+		case 1:
+			ucp->uc_mcontext.gregs[REG_RSI] = va_arg (va, GREG_T);
+			break;
+		case 2:
+			ucp->uc_mcontext.gregs[REG_RDX] = va_arg (va, GREG_T);
+			break;
+		case 3:
+			ucp->uc_mcontext.gregs[REG_RCX] = va_arg (va, GREG_T);
+			break;
+		case 4:
+			ucp->uc_mcontext.gregs[REG_R8] = va_arg (va, GREG_T);
+			break;
+		case 5:
+			ucp->uc_mcontext.gregs[REG_R9] = va_arg (va, GREG_T);
+			break;
+		default:
+			sp[i - 5] = va_arg (va, GREG_T);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/x86_64/setcontext.S b/libucontext/arch/x86_64/setcontext.S
--- a/libucontext/arch/x86_64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* set all of the registers */
+	movq    40(%rdi), %r8
+	movq    48(%rdi), %r9
+	movq    56(%rdi), %r10
+	movq    64(%rdi), %r11
+	movq    72(%rdi), %r12
+	movq    80(%rdi), %r13
+	movq    88(%rdi), %r14
+	movq    96(%rdi), %r15
+	movq    112(%rdi), %rsi
+	movq    120(%rdi), %rbp
+	movq    128(%rdi), %rbx
+	movq    136(%rdi), %rdx
+	movq    144(%rdi), %rax
+	movq    152(%rdi), %rcx
+	movq    160(%rdi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq   168(%rdi)
+
+	/* finally, set %rdi correctly. */
+	movq    104(%rdi), %rdi
+
+	/* we're all done here, return 0 */
+	xorl    %eax, %eax
+	ret
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/startcontext.S b/libucontext/arch/x86_64/startcontext.S
--- a/libucontext/arch/x86_64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movq	%rbx, %rsp
+	movq	(%rsp), %rdi
+	testq	%rdi, %rdi
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	_libucontext_setcontext
+	movq	%rax, %rdi
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	_exit
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
diff -Naur a/libucontext/arch/x86_64/swapcontext.S b/libucontext/arch/x86_64/swapcontext.S
--- a/libucontext/arch/x86_64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	/* copy all of the current registers into the ucontext structure pointed by
+	   the first argument */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* set all of the registers to their new states, stored in the second
+	   ucontext structure */	
+	movq	40(%rsi), %r8
+	movq	48(%rsi), %r9
+	movq	56(%rsi), %r10
+	movq	64(%rsi), %r11
+	movq	72(%rsi), %r12
+	movq	80(%rsi), %r13
+	movq	88(%rsi), %r14
+	movq	96(%rsi), %r15
+	movq	104(%rsi), %rdi
+	movq	120(%rsi), %rbp
+	movq	128(%rsi), %rbx
+	movq	136(%rsi), %rdx
+	movq	144(%rsi), %rax
+	movq	152(%rsi), %rcx
+	movq	160(%rsi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq	168(%rsi)
+
+	/* finally, set %rsi correctly since we do not need it anymore. */
+	movq	112(%rsi), %rsi
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/include/libucontext.h b/libucontext/include/libucontext.h
--- a/libucontext/include/libucontext.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/include/libucontext.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,126 @@
+#ifndef __LIBUCONTEXT_H
+#define __LIBUCONTEXT_H
+
+#include <stdint.h>
+
+/* Structure describing a signal stack.  */
+typedef struct
+  {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } libucontext_stack_t;
+
+typedef unsigned long int libucontext_sigset_t;
+
+#if defined(__aarch64__)
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct
+  {
+    unsigned long long int fault_address;
+    unsigned long long int regs[31];
+    unsigned long long int sp;
+    unsigned long long int pc;
+    unsigned long long int pstate;
+    /* This field contains extension records for additional processor
+       state such as the FP/SIMD state.  It has to match the definition
+       of the corresponding field in the sigcontext struct, see the
+       arch/arm64/include/uapi/asm/sigcontext.h linux header for details.  */
+    unsigned char __reserved[4096] __attribute__ ((__aligned__ (16)));
+  } libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_sigset_t uc_sigmask;
+    libucontext_mcontext_t uc_mcontext;
+  } libucontext_ucontext_t;
+#elif defined(__x86_64__)
+/* Type for general register.  */
+typedef long long int libucontext_greg_t;
+
+/* Container for all general registers.  */
+typedef libucontext_greg_t libucontext_gregset_t[23];
+
+struct libucontext_fpxreg
+{
+  unsigned short int significand[4];
+  unsigned short int exponent;
+  unsigned short int __glibc_reserved1[3];
+};
+
+struct libucontext_xmmreg
+{
+  uint32_t  element[4];
+};
+
+struct libucontext_fpstate
+{
+  /* 64-bit FXSAVE format.  */
+  uint16_t    cwd;
+  uint16_t    swd;
+  uint16_t    ftw;
+  uint16_t    fop;
+  uint64_t    rip;
+  uint64_t    rdp;
+  uint32_t    mxcsr;
+  uint32_t    mxcr_mask;
+  struct libucontext_fpxreg _st[8];
+  struct libucontext_xmmreg _xmm[16];
+  uint32_t    __libucontext_reserved1[24];
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct libucontext_fpstate *libucontext_fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct libucontext_mcontext
+  {
+    libucontext_gregset_t gregs;
+    /* Note that fpregs is a pointer.  */
+    libucontext_fpregset_t fpregs;
+    unsigned long long __reserved1 [8];
+} libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long int uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_mcontext_t uc_mcontext;
+    libucontext_sigset_t uc_sigmask;
+    struct libucontext_fpstate __fpregs_mem;
+    unsigned long long int __ssp[4];
+  } libucontext_ucontext_t;
+#else
+#error "mcontext not implemented!"
+#endif
+
+/* Get user context and store it in variable pointed to by UCP.  */
+int libucontext_getcontext (libucontext_ucontext_t *__ucp);
+
+/* Set user context from information of variable pointed to by UCP.  */
+int libucontext_setcontext (const libucontext_ucontext_t *__ucp);
+
+/* Save current context in context variable pointed to by OUCP and set
+   context from variable pointed to by UCP.  */
+int libucontext_swapcontext (libucontext_ucontext_t *__restrict __oucp,
+      const libucontext_ucontext_t *__restrict __ucp);
+
+/* Manipulate user context UCP to continue with calling functions FUNC
+   and the ARGC-1 parameters following ARGC when the context is used
+   the next time in `setcontext' or `swapcontext'.
+
+   We cannot say anything about the parameters FUNC takes; `void'
+   is as good as any other choice.  */
+void libucontext_makecontext (libucontext_ucontext_t *__ucp, void (*__func) (void),
+       int __argc, ...);
+
+#endif
diff -Naur a/libucontext/test_libucontext.c b/libucontext/test_libucontext.c
--- a/libucontext/test_libucontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/test_libucontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * libucontext test program based on POSIX example program.
+ * Public domain.
+ */
+
+#include <stdio.h>
+#include <ucontext.h>
+#include <stdint.h>
+#include <string.h>
+
+
+static ucontext_t ctx[3];
+
+
+static void f1 (void) {
+	printf("start f1\n");
+	swapcontext(&ctx[1], &ctx[2]);
+	printf("finish f1\n");
+}
+
+
+static void f2 (void) {
+	printf("start f2\n");
+	swapcontext(&ctx[2], &ctx[1]);
+	printf("finish f2\n");
+}
+
+
+int main (int argc, const char *argv[]) {
+	char st1[8192];
+	char st2[8192];
+
+
+	/* poison each coroutine's stack memory for debugging purposes */
+	memset(st1, 'A', sizeof st1);
+	memset(st2, 'B', sizeof st2);
+
+
+	getcontext(&ctx[1]);
+	ctx[1].uc_stack.ss_sp = st1;
+	ctx[1].uc_stack.ss_size = sizeof st1;
+	ctx[1].uc_link = &ctx[0];
+	makecontext(&ctx[1], f1, 0);
+
+
+	getcontext(&ctx[2]);
+	ctx[2].uc_stack.ss_sp = st2;
+	ctx[2].uc_stack.ss_size = sizeof st2;
+	ctx[2].uc_link = &ctx[1];
+	makecontext(&ctx[2], f2, 0);
+
+
+	swapcontext(&ctx[0], &ctx[2]);
+	return 0;
+}
From 5ac17660a76e321c37e6dca2e3c04d9d7d2b7ff4 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Tue, 31 Mar 2020 15:59:19 -0700
Subject: [PATCH] Add DNS resolving for iOS

iOS does not support reading /etc/resolv.conf so we have to use libresolv
Also modified build script to support building on Darwin systems.
---
 meson.build |  10 +++++-
 src/slirp.c | 101 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 108 insertions(+), 3 deletions(-)

diff --git a/meson.build b/meson.build
index 94578dc..f47594f 100644
--- a/slirp/meson.build
+++ b/slirp/meson.build
@@ -50,6 +50,10 @@ if host_system == 'windows'
     cc.find_library('ws2_32'),
     cc.find_library('iphlpapi')
   ]
+elif host_system == 'darwin'
+  platform_deps += [
+    cc.find_library('resolv')
+  ]
 endif
 
 cargs = [
@@ -91,7 +95,11 @@ sources = [
 ]
 
 mapfile = 'src/libslirp.map'
-vflag = '-Wl,--version-script,@0@/@1@'.format(meson.current_source_dir(), mapfile)
+vflag = []
+vflag_test = '-Wl,--version-script,@0@/@1@'.format(meson.current_source_dir(), mapfile)
+if cc.has_link_argument(vflag_test)
+  vflag += vflag_test
+endif
 
 configure_file(
   input : 'src/libslirp-version.h.in',
diff --git a/src/slirp.c b/src/slirp.c
index b0194cb..eb57116 100644
--- a/slirp/src/slirp.c
+++ b/slirp/src/slirp.c
@@ -59,7 +59,7 @@ static unsigned dns6_addr_time;
 /* for the aging of certain requests like DNS */
 #define TIMEOUT_DEFAULT 1000 /* milliseconds */
 
-#ifdef _WIN32
+#if defined(_WIN32)
 
 int get_dns_addr(struct in_addr *pdns_addr)
 {
@@ -116,7 +116,104 @@ static void winsock_cleanup(void)
     WSACleanup();
 }
 
-#else
+#elif defined(__APPLE__)
+
+#include <resolv.h>
+
+static int get_dns_addr_cached(void *pdns_addr, void *cached_addr,
+                               socklen_t addrlen, unsigned *cached_time)
+{
+    struct stat old_stat;
+    if (curtime - *cached_time < TIMEOUT_DEFAULT) {
+        memcpy(pdns_addr, cached_addr, addrlen);
+        return 0;
+    }
+    return 1;
+}
+
+static int get_dns_addr_libresolv(int af, void *pdns_addr, void *cached_addr,
+                                  socklen_t addrlen, uint32_t *scope_id,
+                                  unsigned *cached_time)
+{
+    char buff[512];
+    struct __res_state state;
+    union res_sockaddr_union servers[NI_MAXSERV];
+    int count;
+    int found;
+
+    if (res_ninit(&state) != 0) {
+        return -1;
+    }
+
+    count = res_getservers(&state, servers, NI_MAXSERV);
+    found = 0;
+    DEBUG_MISC("IP address of your DNS(s):");
+    for (int i = 0; i < count; i++) {
+        if (af == servers[i].sin.sin_family) {
+            found++;
+        }
+
+        // we use the first found entry
+        if (found == 1) {
+            memcpy(pdns_addr, &servers[i].sin.sin_addr, addrlen);
+            memcpy(cached_addr, &servers[i].sin.sin_addr, addrlen);
+            if (scope_id) {
+                *scope_id = 0;
+            }
+            *cached_time = curtime;
+        }
+
+        if (found > 3) {
+            DEBUG_MISC("  (more)");
+            break;
+        } else if (slirp_debug & DBG_MISC) {
+            char s[INET6_ADDRSTRLEN];
+            const char *res = inet_ntop(servers[i].sin.sin_family,
+                                        &servers[i].sin.sin_addr,
+                                        s,
+                                        sizeof(s));
+            if (!res) {
+                res = "  (string conversion error)";
+            }
+            DEBUG_MISC("  %s", res);
+        }
+    }
+
+    res_nclose(&state);
+    if (!found)
+        return -1;
+    return 0;
+}
+
+int get_dns_addr(struct in_addr *pdns_addr)
+{
+    if (dns_addr.s_addr != 0) {
+        int ret;
+        ret = get_dns_addr_cached(pdns_addr, &dns_addr, sizeof(dns_addr),
+                                  &dns_addr_time);
+        if (ret <= 0) {
+            return ret;
+        }
+    }
+    return get_dns_addr_libresolv(AF_INET, pdns_addr, &dns_addr,
+                                  sizeof(dns_addr), NULL, &dns_addr_time);
+}
+
+int get_dns6_addr(struct in6_addr *pdns6_addr, uint32_t *scope_id)
+{
+    if (!in6_zero(&dns6_addr)) {
+        int ret;
+        ret = get_dns_addr_cached(pdns6_addr, &dns6_addr, sizeof(dns6_addr),
+                                  &dns6_addr_time);
+        if (ret <= 0) {
+            return ret;
+        }
+    }
+    return get_dns_addr_libresolv(AF_INET6, pdns6_addr, &dns6_addr,
+                                  sizeof(dns6_addr), scope_id, &dns6_addr_time);
+}
+
+#else // !defined(_WIN32) && !defined(__APPLE__)
 
 static int get_dns_addr_cached(void *pdns_addr, void *cached_addr,
                                socklen_t addrlen, struct stat *cached_stat,
-- 
2.24.1 (Apple Git-126)

From 0f83a02f6aac64e5efe0bc7b1058d0e0b8525e91 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Mon, 14 Sep 2020 15:06:29 -0700
Subject: [PATCH] block: check availablity for preadv/pwritev on mac

macOS 11/iOS 14 added preadv/pwritev APIs. Due to weak linking, configure
will succeed with CONFIG_PREADV even when targeting a lower OS version. We
therefore need to check at run time if we can actually use these APIs.
---
 block/file-posix.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/block/file-posix.c b/block/file-posix.c
index c8c13ab218..601074a242 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1396,12 +1396,26 @@ static bool preadv_present = true;
 static ssize_t
 qemu_preadv(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN // preadv introduced in macOS 11
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    }
+    else
+#endif
     return preadv(fd, iov, nr_iov, offset);
 }
 
 static ssize_t
 qemu_pwritev(int fd, const struct iovec *iov, int nr_iov, off_t offset)
 {
+#ifdef CONFIG_DARWIN // pwritev introduced in macOS 11
+    if (!__builtin_available(macOS 11, iOS 14, watchOS 7, tvOS 14, *)) {
+        preadv_present = false;
+        return -ENOSYS;
+    }
+    else
+#endif
     return pwritev(fd, iov, nr_iov, offset);
 }
 
-- 
2.24.3 (Apple Git-128)

